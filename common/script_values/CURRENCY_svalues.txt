CURRENCY_base_starting_amt_circulated_thousands = {
	# Scope: Country
	# Function: Get a value proportionate to the country's economy to start off the size of their gold reserves
	value = country_population
	multiply = 1
	round = floor
}

CURRENCY_gdp_10percent = {
	value = WEALTH_total_private_moveable_wealth
	divide = 10
}

CURRENCY_debt_to_GDP_ratio = {
	value = CURRENCY_national_debt_scaled_wealth_value_millions
	divide = WEALTH_total_private_moveable_wealth_scaled
}

CURRENCY_National_base_import_price_silver_10 = {
	# Scope: Country
	value = global_var:global_base_import_price_silver
	multiply = 10
}

CURRENCY_National_base_import_price_silver = {
	# Scope: Country
	value = global_var:global_base_import_price_silver
}

CURRENCY_National_base_import_price_gold = {
	# Scope: Country
	value = global_var:global_base_import_price_gold
}

CURRENCY_National_base_import_price_gold_10 = {
	# Scope: Country
	value = global_var:global_base_import_price_gold
	multiply = 10
}

CURRENCY_base_starting_reserve_gold = {
	# Scope: Country
	# Function: Get a value proportionate to the country's economy to start off the size of their gold reserves
	if = {
		limit = {
			OR = {
				trigger_if = {
					limit = {
						has_variable = official_currency
					}
					OR = {
						var:official_currency.var:backing_type = flag:silver_standard
						var:official_currency.var:backing_type = flag:bimetallic_standard
					}
				}
				NOT = { has_variable = official_currency }
			}
		}
		value = country_population
		multiply = 0.7
		add = FUNC_cities_10x
		round = floor
	}
	if = {
		limit = {
			trigger_if = {
				limit = {
					has_variable = official_currency
				}
				var:official_currency.var:backing_type = flag:bimetallic_standard
			}
		}
		divide = 2
	}
}

CURRENCY_base_starting_reserve_accumulation_rate_gold = {
	# Scope: Country
	value = CURRENCY_base_starting_reserve_gold
	multiply = 0.1
	round = floor
}

CURRENCY_base_starting_reserve_silver = {
	# Scope: Country
	# Function: Get a value proportionate to the country's economy to start off the size of their silver reserves
	if = {
		limit = {
			OR = {
				trigger_if = {
					limit = {
						has_variable = official_currency
					}
					OR = {
						var:official_currency.var:backing_type = flag:silver_standard
						var:official_currency.var:backing_type = flag:bimetallic_standard
					}
				}
				NOT = { has_variable = official_currency }
			}
		}
		value = country_population
		multiply = 0.28
		add = FUNC_cities_10x
		round = floor
	}
	if = {
		limit = {
			trigger_if = {
				limit = {
					has_variable = official_currency
				}
				var:official_currency.var:backing_type = flag:bimetallic_standard
			}
		}
		divide = 2
	}
}

CURRENCY_base_starting_reserve_accumulation_rate_silver = {
	# Scope: Country
	value = CURRENCY_base_starting_reserve_silver
	multiply = 0.1
	round = floor
}

CURRENCY_wealth_value_10_units = {
	# Scope: Country
	# Function: Get the amount of wealth from minting 1,000, used when adding money to the treasury
	value = CURRENCY_wealth_value_1_unit_scaled_by_reserve_ratio
	multiply = 10
}

CURRENCY_wealth_value_1k_units = {
	# Scope: Country
	# Function: Get the amount of wealth from minting 1,000, used when adding money to the treasury
	value = CURRENCY_wealth_value_1_unit_scaled_by_reserve_ratio
	multiply = 1000
}

CURRENCY_debt_wealth_value_1k_units = {
	value = CURRENCY_wealth_value_1k_units
	divide = 10
}

CURRENCY_wealth_value_10k_units = {
	# Scope: Country
	# Function: Get the amount of wealth from minting 1,000, used when adding money to the treasury
	value = CURRENCY_wealth_value_1_unit_scaled_by_reserve_ratio
	multiply = 10000
}

CURRENCY_wealth_value_100k_units = {
	# Scope: Country
	# Function: Get the amount of wealth from minting 1,000, used when adding money to the treasury
	value = CURRENCY_wealth_value_1_unit_scaled_by_reserve_ratio
	multiply = 100000
}

CURRENCY_debt_wealth_value_10k_units = {
	value = CURRENCY_wealth_value_10k_units
	divide = 10
}

CURRENCY_debt_wealth_value_100k_units = {
	value = CURRENCY_wealth_value_10k_units
	multiply = 10
}

CURRENCY_wealth_value_1k_units_basic = {
	value = CURRENCY_wealth_value_1_unit
	multiply = 1000
}

CURRENCY_wealth_value_100_units_basic = {
	value = CURRENCY_wealth_value_1_unit
	multiply = 100
}

CURRENCY_wealth_value_10_units_basic = {
	value = CURRENCY_wealth_value_1_unit
	multiply = 10
}

CURRENCY_wealth_value_10_units_negative = {
	value = CURRENCY_wealth_value_1_unit
	multiply = -10
}

CURRENCY_wealth_value_1k_units_negative = {
	value = CURRENCY_wealth_value_1_unit
	multiply = -1000	
}

CURRENCY_debt_wealth_value_1k_units_negative = {
	value = CURRENCY_wealth_value_1k_units_negative
	divide = 10
}

CURRENCY_wealth_value_10k_units_negative = {
	# Scope: Country
	# Function: Get the amount of wealth from minting 1,000, used when adding money to the treasury
	value = CURRENCY_wealth_value_1_unit
	multiply = -100000
}

CURRENCY_wealth_value_100k_units_negative = {
	# Scope: Country
	# Function: Get the amount of wealth from minting 1,000, used when adding money to the treasury
	value = CURRENCY_wealth_value_1_unit
	multiply = -100000
}

CURRENCY_debt_wealth_value_10k_units_negative = {
	value = CURRENCY_wealth_value_10k_units_negative
	divide = 100
}

CURRENCY_debt_wealth_value_100k_units_negative = {
	value = CURRENCY_wealth_value_10k_units_negative
	divide = 10
}

CURRENCY_repay_debt_1k_interest_cost = {
	value = CURRENCY_debt_wealth_value_1k_units_negative
	multiply = CURRENCY_national_debt_interest_actual
}

CURRENCY_repay_debt_10k_interest_cost = {
	value = CURRENCY_debt_wealth_value_10k_units_negative
	multiply = CURRENCY_national_debt_interest_actual
}

CURRENCY_wealth_value_1_unit = {
	# Scope: Country
	# Function: Get the amount of "wealth" units that 1 unit of this country's currency can buy according to its pegged reserve value
	if = {
		limit = {
			trigger_if = {
				limit = {
					has_variable = official_currency
				}
				var:official_currency = {
					var:backing_type = flag:bimetallic_standard
				}
			}
		}
		value = CURRENCY_wealth_value_bimetallic_from_gold
		add = CURRENCY_wealth_value_bimetallic_from_silver
	}
	else_if = {
		limit = {
			trigger_if = {
				limit = {
					has_variable = official_currency
				}
				var:official_currency.var:backing_type = flag:gold_standard
			}
		}
		value = CURRENCY_wealth_value_from_gold
	}
	else_if = {
		limit = {
			trigger_if = {
				limit = {
					has_variable = official_currency
				}
				var:official_currency.var:backing_type = flag:silver_standard
			}
		}
		value = CURRENCY_wealth_value_from_silver
	}
	else = {
		value = 999 # TEST
	}
	divide = var:official_currency.var:units_to_the_lb
	#multiply = 10
}

CURRENCY_wealth_value_1_unit_scaled_by_reserve_ratio = {
	# Scope: Country
	value = CURRENCY_wealth_value_1_unit
	multiply = CURRENCY_wealth_value_reserve_ratio_minting_impact
}

CURRENCY_wealth_value_1_unit_scaled_by_reserve_ratio_x1k = {
	# Function: Get the value of 1,000 units of currency, to issue £1k of national debt
	value = CURRENCY_wealth_value_1_unit_scaled_by_reserve_ratio
	multiply = 1000
}

CURRENCY_wealth_value_reserve_ratio_minting_impact = {
	value = CURRENCY_reserve_ratio_impact
}

CURRENCY_ideal_reserve_ratio_multiplier_gold = {
	# Scope: Country
	# Function: Take the reserve ACTUAL accumulation rate (never mind the target) and divide it by the total reserve size. This gives the multiplier for minting value given by the reserve ratio.
	# The ideal reserve ratio % (i.e. maximum reserve ratio size before the bonus caps out) is THIS divided by 100
	value = 0
	if = {
		limit = {
			has_variable = gold_reserve_actual_change
		}
		add = var:gold_reserve_actual_change
	}
	#multiply = 10
	divide = CURRENCY_total_country_cash_scaled
	#multiply = 30
	if = {
		limit = {
			var:official_currency.var:backing_type = flag:bimetallic_standard
		}
		multiply = CURRENCY_wealth_bimetallic_gold_as_percentage
	}
	multiply = 0.5
}

CURRENCY_ideal_reserve_ratio_multiplier_silver = {
	# Scope: Country
	# Function: Take the reserve ACTUAL accumulation rate (never mind the target) and divide it by the total reserve size. This gives the multiplier for minting value given by the reserve ratio.
	# The ideal reserve ratio % (i.e. maximum reserve ratio size before the bonus caps out) is THIS divided by 100
	value = 0
	if = {
		limit = {
			has_variable = silver_reserve_actual_change
		}
		add = var:silver_reserve_actual_change
	}
	divide = CURRENCY_total_country_cash_scaled
	if = {
		limit = {
			var:official_currency.var:backing_type = flag:bimetallic_standard
		}
		multiply = CURRENCY_wealth_bimetallic_silver_as_percentage
	}
	multiply = 0.5
}

CURRENCY_ideal_reserve_ratio = {
	# Scope: Country
	# Function: Get the ideal reserve ratio multiplier based on the metallic standard in use
	# Take the reserve ACTUAL accumulation rate (never mind the target) and divide it by the total reserve size. This gives the multiplier for minting value given by the reserve ratio.
	value = 0.5
	if = {
		limit = {
			var:official_currency.var:backing_type = flag:bimetallic_standard
		}
		subtract = CURRENCY_ideal_reserve_ratio_multiplier_gold
		subtract = CURRENCY_ideal_reserve_ratio_multiplier_silver
	}
	else_if = {
		limit = {
			var:official_currency.var:backing_type = flag:gold_standard
		}
		subtract = CURRENCY_ideal_reserve_ratio_multiplier_gold
	}
	else_if = {
		limit = {
			var:official_currency.var:backing_type = flag:silver_standard
		}
		subtract = CURRENCY_ideal_reserve_ratio_multiplier_silver
	}
	if = {
		limit = {
			NOT = {
				has_variable = public_debt_administration
			}
		}
		multiply = 3.5
	}
	#divide = CURRENCY_reserve_to_gdp_ratio
	min = 0.05
}

CURRENCY_reserve_ratio_impact = {
	# Scope: Country
	if = {
		limit = {
			has_variable = public_debt_administration
			CURRENCY_reserve_ratio_total < 1
		}
		value = CURRENCY_reserve_ratio_total
		multiply = {
			value = 5
			subtract = CURRENCY_reserve_ratio_total
		}
		max = 1
	}
	else = {
		value = CURRENCY_reserve_ratio_total
		divide = 3
		min = 0
	}
	max = 1
	min = 0
}

CURRENCY_stability_impact_ideal_reserve_ratio = {
	if = {
		limit = {
			stability > 0
		}
		value = stability
		multiply = 0.01
	}
	else_if = {
		limit = {
			stability = 0
		}
		value = 0
	}
}

CURRENCY_wealth_bimetallic_gold_as_percentage = {
	# Scope: Country
	# Function: Get the % of the reserve made up of gold
	value = var:gold_reserve_size
	divide = CURRENCY_wealth_bimetallic_both_reserves_size
}

CURRENCY_wealth_bimetallic_silver_as_percentage = {
	# Scope: Country
	# Function: Get the % of the reserve made up of gold
	value = var:silver_reserve_size
	divide = CURRENCY_wealth_bimetallic_both_reserves_size
}

CURRENCY_wealth_bimetallic_both_reserves_size = {
	# Scope: Country
	# Function: Add both metal reserves together
	value = var:gold_reserve_size
	add = var:silver_reserve_size
}

CURRENCY_wealth_value_bimetallic_from_gold = {
	# Scope: Country
	# Function: Get the amount of value that gold is contributing to the country's currency value
	value = var:gold_reserve_size
	divide = CURRENCY_wealth_bimetallic_both_reserves_size
	multiply = var:country_unit_price_gold
	multiply = 16 # 16 ounces to the pound, which is the base ratio
}

CURRENCY_wealth_value_bimetallic_from_silver = {
	# Scope: Country
	# Function: Get the amount of value that gold is contributing to the country's currency value
	value = var:silver_reserve_size
	divide = CURRENCY_wealth_bimetallic_both_reserves_size
	multiply = var:country_unit_price_silver
	multiply = 16 # 16 ounces to the pound, which is the base ratio
}

CURRENCY_wealth_value_from_silver = {
	value = var:country_unit_price_silver
	multiply = 16
}

CURRENCY_wealth_value_from_gold = {
	value = var:country_unit_price_gold
	multiply = 16
}

CURRENCY_debt_issue_political_influence_cost_1k = {
	# Scope: Country
	# Function: Get the cost of issuing 1,000 units worth of new debt in terms of political influence
	value = CURRENCY_wealth_value_10_units
	multiply = -1
}
CURRENCY_debt_issue_political_influence_cost_10k = {
	# Scope: Country
	# Function: Get the cost of issuing 10,000 units worth of new debt in terms of political influence
	value = CURRENCY_wealth_value_10_units
	multiply = -10
}
CURRENCY_debt_issue_political_influence_cost_100k = {
	# Scope: Country
	# Function: Get the cost of issuing 100,000 units worth of new debt in terms of political influence
	value = CURRENCY_wealth_value_10_units
	multiply = -100
}
CURRENCY_debt_issue_political_influence_cost_1m = {
	# Scope: Country
	# Function: Get the cost of issuing 1,000,000 units worth of new debt in terms of political influence
	value = CURRENCY_wealth_value_10_units
	multiply = -1000
}

CURRENCY_national_debt_scaled = {
	# Scope: Country
	# Function: Take the national debt value and scale it down by a factor of 1-,000 to prevent overflows (as this goes into the billions)
	value = CURRENCY_national_debt_thousands_scaled
	add = CURRENCY_national_debt_millions_scaled
	add = CURRENCY_national_debt_billions_scaled
}

CURRENCY_national_debt_scaled_wealth_value_millions = {
	# Scope: Country
	# Function: Get the value of the national debt in millions of wealth units
	value = var:CURRENCY_national_debt
	multiply = CURRENCY_wealth_value_1_unit
}

CURRENCY_national_debt_thousands_scaled = {
	value = var:CURRENCY_national_debt_thousands
	divide = 1000
}

CURRENCY_national_debt_millions_scaled = {
	value = var:CURRENCY_national_debt_millions
}

CURRENCY_national_debt_billions_scaled = {
	value = var:CURRENCY_national_debt_billions
	multiply = 1000
}

CURRENCY_amt_circulated_scaled = {
	# Scope: Country
	# Function: Take the amount circulated value and scale it down by a factor of 10,000 to prevent overflows (as this goes into the billions)
	value = CURRENCY_amt_circulated_thousands_scaled
	add = CURRENCY_amt_circulated_millions_scaled
	add = CURRENCY_amt_circulated_billions_scaled
}

CURRENCY_amt_circulated_thousands_scaled = {
	value = var:CURRENCY_amt_circulated_thousands
	divide = 1000
}

CURRENCY_amt_circulated_millions_scaled = {
	value = var:CURRENCY_amt_circulated_millions
}

CURRENCY_amt_circulated_billions_scaled = {
	value = var:CURRENCY_amt_circulated_billions
	multiply = 1000
}

CURRENCY_total_country_cash_scaled = {
	# Scope: Country
	# Function: Get the total amount of public and private cash in a country
	value = CURRENCY_national_debt_scaled
	add = CURRENCY_amt_circulated_scaled
}

CURRENCY_reserve_value_in_cash_scaled = {
	# Scope: Country
	# Function: Get the value of the country's percious metal reserves in currency units, divided by 10,000 (to scale wtih CURRENCY_total_country_cash_scaled)
	if = {
		limit = {
			var:official_currency.var:backing_type = flag:bimetallic_standard
		}
		value = CURRENCY_wealth_bimetallic_both_reserves_size
	}
	else_if = {
		limit = {
			var:official_currency.var:backing_type = flag:gold_standard
		}
		value = var:gold_reserve_size
	}
	else_if = {
		limit = {
			var:official_currency.var:backing_type = flag:silver_standard
		}
		value = var:silver_reserve_size
	}
	divide = 10000
	multiply = var:official_currency.var:units_to_the_lb
}

CURRENCY_reserve_value_in_cash_scaled_silver = {
	# Scope: Country
	# Function: Get the value of the silver reserve in cash, in the millions
	value = var:silver_reserve_size
	divide = 100
	multiply = var:official_currency.var:units_to_the_lb
	divide = 100
}

CURRENCY_reserve_value_in_wealth_silver = {
	# Scope: Country
	# Function: Get the wealth value of the silver reserve
	value = var:silver_reserve_size
	multiply = global_var:global_base_import_price_silver
}

CURRENCY_reserve_value_in_cash_scaled_gold = {
	# Scope: Country
	# Function: Get the value of the gold reserve in cash, in the millions
	value = var:gold_reserve_size
	divide = 100
	multiply = var:official_currency.var:units_to_the_lb
	divide = 100
}

CURRENCY_reserve_value_in_wealth_gold = {
	# Scope: Country
	# Function: Get the wealth value of the gold reserve
	value = var:gold_reserve_size
	multiply = global_var:global_base_import_price_gold
}

CURRENCY_reserve_ratio_total = {
	# Scope: Country
	# Function: The ratio of currency in national debt and privately held cash, against the value of the precious metal reserves
	#value = CURRENCY_reserve_value_in_cash_scaled
	value = 0
	var:official_currency = {
		every_in_list = {
			variable = currency_adopted_countries

			add = CURRENCY_reserve_value_in_cash_scaled
		}
	}
	#value = CURRENCY_reserve_value_in_cash_scaled
	divide = CURRENCY_total_country_cash_scaled_for_reserve_ratio
	min = 0
}

CURRENCY_total_country_cash_scaled_for_reserve_ratio = {
	# Scope: Country
	# Function: Add the amount of cash in every country using this currency
	value = 0.001
	var:official_currency = {
		every_in_list = {
			variable = currency_adopted_countries

			add = CURRENCY_total_country_cash_scaled
		}
	}
}

CURRENCY_essentials_buying_power = {
	# Scope: Country
	# Function: Gets the effective buying power of the currency for ordinary people, based on how expensive to buy a quarter's worth of essential goods
	# AKA cost of living, cost_of_living
	value = var:country_unit_price_grain
	add = var:country_unit_price_livestock
	add = var:country_unit_price_fish
	add = var:country_unit_price_vegetables
	add = var:country_unit_price_temperate_fruit
	add = var:country_unit_price_processed_foods
	add = var:country_unit_price_clothing
	add = var:country_unit_price_furniture
	add = var:country_unit_price_pharmaceuticals
	add = var:country_unit_price_alcohol
	add = var:country_unit_price_luxury_clothing
	add = var:country_unit_price_luxury_furniture

	if = {
		limit = {
			CURRENCY_wealth_value_1_unit_scaled_by_reserve_ratio > 0
		}
		divide = CURRENCY_wealth_value_1_unit_scaled_by_reserve_ratio
	}
	else = {
		multiply = 32000
	}
	#divide = 1
	max = 32000
}

CURRENCY_essentials_buying_power_unweighted = {
	value = var:country_unit_price_grain
	add = var:country_unit_price_livestock
	add = var:country_unit_price_fish
	add = var:country_unit_price_vegetables
	add = var:country_unit_price_temperate_fruit
	add = var:country_unit_price_processed_foods
	add = var:country_unit_price_clothing
	add = var:country_unit_price_furniture
	add = var:country_unit_price_pharmaceuticals
	add = var:country_unit_price_alcohol

	divide = CURRENCY_wealth_value_1_unit
	divide = 4
}

CURRENCY_private_cash_needed = {
	# Scope: Country
	# Function: Multiply the cost of living by the country population.
	# This gives the minimum amount of cash that must be in circulation for pops to carry out day to day business. Anything less will cause serious deflation, i.e. demand for goods to drop and for a base level of shortages in every region
	value = CURRENCY_essentials_buying_power
	multiply = country_population
	divide = 4000 # Divide by 4,000 to scale down to CURRENCY_amt_circulated which is measured in the millions, and scaled to the size of a family unit (est. 4 people)
	# Add the amount required from trade
	subtract = {
		value = CURRENCY_trade_wealth_outgoing_currency_value
	}
	add = CURRENCY_wealth_generated_country_as_currency_value
	divide = 2000
}

CURRENCY_wealth_generated_country_as_currency_value = {
	value = 0
	every_governorships = {
		add = WEALTH_total_new_generated_governorship
	}
	divide = CURRENCY_wealth_value_1_unit
}

CURRENCY_private_cash_needed_unweighted = {
	# Scope: Country
	# Function: Multiply the cost of living by the country population.
	# SPECIAL - does not weight the need by the reserve ratio, so that this can be used in the ideal reserve ratio calculation
	# This gives the minimum amount of cash that must be in circulation for pops to carry out day to day business. Anything less will cause serious deflation, i.e. demand for goods to drop and for a base level of shortages in every region
	value = CURRENCY_essentials_buying_power_unweighted
	multiply = 4 # Multiply by 4, each pop is 4,000 people and this value will be scaled down to avoid overflows
	multiply = country_population
	divide = 1000 # Divide by 1,000 to scale down to CURRENCY_amt_circulated which is measured in the millions
}

CURRENCY_private_cash_ratio = {
	# Scope: Country
	# Function: Get the amount of private currency and divide it by the amount needed to support cost of living. If it's too low, the country will experience deflation as there is not enough money circulating
	# This also sets the demand for private cash, and will cause pops to create new cash from commerce districts independently
	# The government can set a rate at which private cash is created or recalled quarterly
	value = CURRENCY_amt_circulated_scaled
	divide = {
		value = CURRENCY_private_cash_needed
		min = 0.01
	}
	min = 0

}

CURRENCY_private_cash_ratio_unweighted = {
	value = CURRENCY_amt_circulated_scaled_10x
	divide = CURRENCY_private_cash_needed_unweighted
	divide = CURRENCY_reserve_ratio_total
	#multiply = 15
}

CURRENCY_units_to_the_lb_reciprocal = {
	value = 1
	divide = var:official_currency.var:units_to_the_lb
}

# Minting rate

CURRENCY_amt_circulated_scaled_1percent = {
	# Scope: Country
	# Function: Get 1 percent of the scaled amount of wealth circulated
	value = CURRENCY_amt_circulated_scaled
	divide = 100
}

CURRENCY_amt_circulated_scaled_10percent = {
	# Scope: Country
	# Function: Get 1 percent of the scaled amount of wealth circulated
	value = CURRENCY_amt_circulated_scaled
	divide = 10
}

CURRENCY_amt_circulated_scaled_10x = {
	# Scope: Country
	# Function: Get 1 percent of the scaled amount of wealth circulated
	value = CURRENCY_amt_circulated_scaled
	multiply = 10
}

CURRENCY_reserve_change_currency_value = {
	# Scope: Country
	# Function: Get the 1,000s value of currency in reserve change rates
	value = var:gold_reserve_actual_change
	add = var:silver_reserve_actual_change
	divide = 100
	multiply = var:official_currency.var:units_to_the_lb
	round = floor
}

CURRENCY_reserve_change_currency_value_for_minting = {
	# Scope: Country
	# Function: Get 10% of the reserve growth as mintable currency
	if = {
		limit = {
			CURRENCY_reserve_change_currency_value > 0
		}
		value = CURRENCY_reserve_change_currency_value
		#divide = 10
	}
	else = {
		value = 0
	}
}

CURRENCY_minting_rate_cap = {
	# Scope: Country
	# Function: Defines the maximum of new currency that can be minted every month
	# The formula is:
	# If paper money is NOT legal
	# Cap = gold_reserve_actual_change + silver_reserve_actual_change
	# + 1% of amount in circulation (for coin recycling)
	if = {
		limit = {
			var:official_currency.var:paper_money_allowed = flag:false
		}
		value = CURRENCY_reserve_change_currency_value_for_minting
		add = CURRENCY_amt_circulated_scaled_1percent
		add = CURRENCY_trade_wealth_income
		add = CURRENCY_minting_from_sister_countries
		round = floor
	}

	# If paper money is legal then there is no cap!
	else = {
		value = 99999
	}
}

CURRENCY_minting_from_sister_countries = {
	# Scope: Country
	# Function: Factor in the extra coinage that can be recycled from other countries using the same currency
	value = 0
	var:official_currency = {
		every_in_list = {
			variable = currency_adopted_countries

			limit = {
				NOT = { THIS = ROOT }
			}

			add = var:TRADE_national_expenditure
		}
	}
	divide = -28
}

CURRENCY_minting_rate_wealth_value = {
	# Scope: Country
	# Function: Calculates the amount of wealth created by minting coins every month
	if = {
		limit = {
			has_variable = CURRENCY_minting_rate
		}
		value = var:CURRENCY_minting_rate
		subtract = CURRENCY_amt_circulated_scaled_1percent
		min = 0
		multiply = CURRENCY_wealth_value_1_unit_scaled_by_reserve_ratio
		multiply = 10
	}
	else = {
		value = 0
	}
}

CURRENCY_minting_rate_wealth_value_per_capita = {
	value = CURRENCY_minting_rate_wealth_value
	divide = country_population
}

# Private currency fluctuation due to trade

CURRENCY_trade_wealth_income = {
	# Scope: Country
	# Function: Tracks the amount of mintable coming into the country from foreign currency
	value = var:TRADE_national_income
	# We divide by the value of wealth in 1 unit of currency, as that is what we are converting when melting down foreign currency to make our own
	divide = CURRENCY_wealth_value_1_unit
	# This is quarterly income, so we divide by 4 for every quarter
	divide = 4
	round = floor
}

CURRENCY_trade_wealth_outgoing_currency_value = {
	# Scope: Country
	# Function: Get the amount of your currency being sent abroad in trade, which is subtracted from privately held cash every month
	value = 1
	if = {
		limit = {
			has_variable = TRADE_national_expenditure
		}
		value = var:TRADE_national_expenditure
	}
	divide = CURRENCY_wealth_value_1_unit
	# This is quarterly income, so we divide by 4 for every quarter
	divide = 4
	round = floor
}

CURRENCY_amt_circulated_balance = {
	value = CURRENCY_trade_wealth_outgoing_currency_value
	add = var:CURRENCY_minting_rate
	if = {
		limit = {
			CURRENCY_amt_circulated_inflation > 0
			NOT = {
				has_variable = reserves_frozen
			}
		}
		subtract = CURRENCY_inflation_cash_selloff_amt
	}
	if = {
		limit = {
			CURRENCY_amt_circulated_deflation > 0
			NOT = {
				has_variable = reserves_frozen
			}
		}
		add = CURRENCY_deflation_money_demand_amt
	}
}

# New wealth to governorships based on minting

CURRENCY_governorship_wealth_from_minting = {
	# Scope: Governorship
	value = owner.CURRENCY_minting_rate_wealth_value
	multiply = FUNC_governorship_country_pops_ratio
}

CURRENCY_governorship_wealth_due_to_upper_strata = {
	value = CURRENCY_governorship_wealth_from_minting
	multiply = {
		value = FUNC_governorship_ratio_upper_strata
		add = FUNC_governorship_ratio_slaves
		add = FUNC_governorship_ratio_indentured
	}
}

CURRENCY_governorship_wealth_due_to_middle_strata = {
	value = CURRENCY_governorship_wealth_from_minting
	multiply = FUNC_governorship_ratio_middle_strata
}

CURRENCY_governorship_wealth_due_to_lower_strata = {
	value = CURRENCY_governorship_wealth_from_minting
	multiply = FUNC_governorship_ratio_lower_strata
}

CURRENCY_governorship_wealth_due_to_proletariat = {
	value = CURRENCY_governorship_wealth_from_minting
	multiply = FUNC_governorship_ratio_proletariat
}

CURRENCY_governorship_wealth_due_to_indentured = {
	value = CURRENCY_governorship_wealth_from_minting
	multiply = FUNC_governorship_ratio_indentured
}

CURRENCY_governorship_wealth_due_to_tribesmen = {
	value = CURRENCY_governorship_wealth_from_minting
	multiply = FUNC_governorship_ratio_tribesmen
}

# NATIONAL DEBT INTEREST RATES

CURRENCY_national_debt_interest_base = {
	# Scope: Country
	# Function: The base rate of national interest if Debt = 100% of GDP
	value = 0.01
}

CURRENCY_national_debt_interest_impact_from_stability = {
	if = {
		limit = {
			stability > 0
		}
		value = {
			value = 1
			divide = {
				value = stability
				divide = 100
			}
		}
	}
	else = {
		value = 100
	}
}

CURRENCY_national_debt_interest_impact_from_war_exhaustion = {
	if = {
		limit = {
			has_war_exhaustion > 0
		}
		value = {
			value = has_war_exhaustion
			divide = 300
		}
	}
	else = {
		value = 0
	}
}

CURRENCY_national_debt_interest_actual = {
	# Scope: Country
	# Function: The interest rate of the given country based on its debt/GDP ratio
	value = CURRENCY_national_debt_interest_base
	multiply = CURRENCY_debt_to_GDP_ratio
	multiply = CURRENCY_national_debt_interest_impact_from_stability
	add = CURRENCY_national_debt_interest_impact_from_war_exhaustion
}

CURRENCY_national_debt_interest_actual_wealth_cost = {
	# Scope: Country
	# Function: The amount of wealth to be subtracted from the national treasury every quarter
	if = {
		limit = {
			has_variable = official_currency
		}
		value = CURRENCY_national_debt_interest_actual
		multiply = CURRENCY_national_debt_scaled_wealth_value_millions
		multiply = -1
	}
	else = {
		value = 0
	}
}

# RESERVE TO GDP SCALES

CURRENCY_reserve_to_gdp_ratio = {
	value = CURRENCY_reserve_value_in_wealth_total
	if = {
		limit = {
			WEALTH_total_private_moveable_wealth_scaled > 0
		}
		divide = WEALTH_total_private_moveable_wealth_scaled
	}
	divide = 100
}

CURRENCY_reserve_value_in_wealth_total = {
	value = CURRENCY_reserve_value_in_wealth_silver
	add = CURRENCY_reserve_value_in_wealth_gold
}

# Reference to gold and silver global values

CURRENCY_global_base_import_price_gold = {
	value = global_var:global_base_import_price_gold
}

CURRENCY_global_base_import_price_silver = {
	value = global_var:global_base_import_price_silver
}

CURRENCY_global_base_import_price_gold_10 = {
	value = global_var:global_base_import_price_gold
	multiply = 10
}

CURRENCY_global_base_import_price_silver_10 = {
	value = global_var:global_base_import_price_silver
	multiply = 10
}

# Starting base currency values

CURRENCY_base_starting_amt_circulated_scaled = {
	# Scope: Country
	# Function: Get the amount of currency to start with, if not defined elsewhere
	value = var:official_currency.var:units_to_the_lb
	multiply = WEALTH_total_private_moveable_wealth_scaled
	#multiply = 0.6
	add = country_population
	multiply = 8
	min = 1
}

# Money supply effects - deflation and inflation

CURRENCY_amt_circulated_deflation = {
	# Scope: Country
	# Function: Calculate the deflation impact from insufficient money supply, which is subtracted from base demand for tradegoods from pops, and added onto the shortage for all tradegoods
	value = 0
	if = {
		limit = {
			has_variable = CURRENCY_amt_circulated_thousands
			CURRENCY_private_cash_ratio < 1
		}
		value = 1
		subtract = CURRENCY_private_cash_ratio
		min = 0.001
		divide = 10
	}
}

CURRENCY_amt_circulated_deflation_demand_multiplier = {
	# Scope: Country
	# Function: Get the value by which to multiply pop demand based on inflation
	value = 1
	subtract = CURRENCY_amt_circulated_deflation
}

CURRENCY_amt_circulated_inflation = {
	# Scope: Country
	# Function: Calculate the inflation impact from excess money supply, which is added to base demand for tradegoods from pops
	value = 0
	if = {
		limit = {
			has_variable = CURRENCY_amt_circulated_thousands
			CURRENCY_private_cash_ratio > 1
		}
		value = CURRENCY_private_cash_ratio
		subtract = 1
		divide = 10
	}
}

CURRENCY_amt_circulated_inflation_demand_multiplier = {
	value = CURRENCY_amt_circulated_inflation
	add = 1
}

CURRENCY_amt_circulated_inflation_100th = {
	value = 0
	if = {
		limit = {
			CURRENCY_amt_circulated_inflation > 0
		}
		value = CURRENCY_amt_circulated_inflation
		divide = 100
	}
}

CURRENCY_amt_circulated_inflation_wealth_multiplier = {
	# Scope: Country
	# Function: Calculate % loss to pop wealth every quarter from excess money supply
	value = 1
	if = {
		limit = {
			CURRENCY_amt_circulated_inflation > 0
		}
		subtract = CURRENCY_amt_circulated_inflation_100th
	}
}

CURRENCY_inflation_cash_selloff_amt = {
	# Scope: Country
	# Function: Determine how much reserve metal pops are trying to buy with their inflated cash
	value = CURRENCY_amt_circulated_inflation
	divide = 5
	multiply = CURRENCY_amt_circulated_scaled
}

CURRENCY_inflation_cash_selloff_amt_display = {
	# Scope: Country
	# Function: Determine how much reserve metal pops are trying to buy with their inflated cash
	value = CURRENCY_inflation_cash_selloff_amt
	if = {
		limit = {
			has_variable = reserves_frozen
		}
		value = 0
	}
}

CURRENCY_inflation_precious_metal_reserve_bought = {
	# Scope: Country
	# Function: Get the value, in hundreds of lbs, of reserve currency being bought by pops due to inflation
	value = CURRENCY_inflation_cash_selloff_amt
	multiply = 10
	divide = var:official_currency.var:units_to_the_lb
}

CURRENCY_deflation_money_demand_amt = {
	# Scope: Country
	# Function: Extra money that is created by pops creating new money with private banks
	value = CURRENCY_amt_circulated_deflation
	multiply = 3000
}

CURRENCY_deflation_money_demand_amt_display = {
	value = CURRENCY_deflation_money_demand_amt
	if = {
		limit = {
			has_variable = reserves_frozen
		}
		value = 0
	}
}

CURRENCY_deflation_money_bought_precious_metal_sold = {
	# Scope Country
	# Function: Get the value in precious metal of the reserve sold
	value = CURRENCY_deflation_money_demand_amt
	divide = var:official_currency.var:units_to_the_lb
	multiply = 10
}

CURRENCY_reserve_accumulation_rate_from_inflation_or_deflation = {
	value = 0
	if = {
		limit = {
			CURRENCY_amt_circulated_deflation > 0
		}
		value = CURRENCY_deflation_money_bought_precious_metal_sold
	}
	if = {
		limit = {
			CURRENCY_amt_circulated_inflation > 0
		}
		subtract = CURRENCY_inflation_precious_metal_reserve_bought		
	}
}

CURRENCY_silver_reserve_size = {
	value = var:silver_reserve_size
}

CURRENCY_gold_reserve_size = {
	value = var:gold_reserve_size
}

CURRENCY_gold_reserve_actual_change_with_cashout = {
	value = var:gold_reserve_actual_change
	if = {
		limit = {
			NOT = { has_variable = reserves_frozen }
			var:gold_reserve_size > CURRENCY_silver_reserve_size
		}
		subtract = 	CURRENCY_inflation_precious_metal_reserve_bought
		add = CURRENCY_deflation_money_bought_precious_metal_sold
	}
}

CURRENCY_silver_reserve_actual_change_with_cashout = {
	value = var:silver_reserve_actual_change
	if = {
		limit = {
			NOT = { has_variable = reserves_frozen }
			var:silver_reserve_size > CURRENCY_gold_reserve_size
		}
		subtract = 	CURRENCY_inflation_precious_metal_reserve_bought
		add = CURRENCY_deflation_money_bought_precious_metal_sold
	}
}


CURRENCY_change_value_stability_impact = {
	# Scope: Country
	# Function: Scale the stability impact of changing currency value based on the current currency, so that a currency with a very high cash:reserve exchange rate impacts stability less
	value = 100
	divide = var:official_currency.var:units_to_the_lb
	multiply = -1
}

CURRENCY_change_value_PI_cost = {
	value = CURRENCY_change_value_stability_impact
	multiply = 10
}

CURRENCY_change_value_PI_cost_neg = {
	value = CURRENCY_change_value_PI_cost
	multiply = -1
}

CURRENCY_change_value_stability_impact_neg = {
	value = CURRENCY_change_value_stability_impact
	multiply = -1
}

## FUNC

CURRENCY_amt_circulated_thousands_rounded = {
	value = local_var:amt_circulated_thousands_rounded
	subtract = 0.5
	round = floor
}

### GLOBAL FINANCE

CURRENCY_exchange_rate_to_player = {
	# Scope: Province (currency obj)
	# Note: AFAIK this only works in GUI
	if = {
		limit = {
			scope:player = {
				NOT = { has_variable = official_currency }
			}
		}
		value = var:originator_country.CURRENCY_wealth_value_1_unit
	}
	
	else = {
		value = scope:player.CURRENCY_wealth_value_1_unit
		divide = var:originator_country.CURRENCY_wealth_value_1_unit
	}
}

CURRENCY_tradezone_bonus_to_power = {
	# Scope: Tradezone province, if any
	# Function: Determines the bonus from having a currency present in a tradezone
	value = 90
}

CURRENCY_power = {
	# Scope: Province (currency obj)
	# Function: Get the global power of the currency, which provides scaling benefits to countries using it
	# Reduces the wealth cost of imports

	every_in_list = {
		variable = currency_adopted_countries

		add = {
			value = WEALTH_national_total
			divide = 1000
			# Add income from exports - which it is preferable to pay in the exporter's currency

			# REMOVED - redundant when we use balance which already takes into account the balance of exports and imports
			#add = {
			#	value = TRADE_national_income
			#	multiply = 5
			#}
			# Add trade balance
			add = {
				value = TRADE_national_balance
				multiply = 10
			}
			# Add income from shipping - which it is preferable to pay in the exporter's currency
			# Add new wealth generated by production and services

			# REMOVED - performance impact outweighs value in calculation
			#every_governorships = {
			#	add = {
			#		value = var:trade_income_due_shipping
			#		add = WEALTH_total_new_generated_governorship
			#	}
			#}
			multiply = {
				value = 1
				add = CURRENCY_reserve_ratio_impact
			}
		}

		add = {
			value = 0
			if = {
				limit = {
					has_variable = TZ_penetration_india
				}
				add = { 
			        value = var:TZ_penetration_india
			        multiply = {
			                value = global_var:global_india_tradezone.var:TZ_shipping
			                max = global_var:global_india_tradezone.SHIPPING_total_in_TZ
			                divide = CURRENCY_power_TZ_penetration_score_modifier
			        }
				}
				add = { 
				        value = var:TZ_penetration_east_north_america
				        multiply = {
				                value = global_var:global_east_north_america_tradezone.var:TZ_shipping
				                max = global_var:global_east_north_america_tradezone.SHIPPING_total_in_TZ
				                divide = CURRENCY_power_TZ_penetration_score_modifier
				        }
				}
				add = { 
				        value = var:TZ_penetration_west_north_america
				        multiply = {
				                value = global_var:global_west_north_america_tradezone.var:TZ_shipping
				                max = global_var:global_west_north_america_tradezone.SHIPPING_total_in_TZ
				                divide = CURRENCY_power_TZ_penetration_score_modifier
				        }
				}
				add = { 
				        value = var:TZ_penetration_caribbean
				        multiply = {
				                value = global_var:global_caribbean_tradezone.var:TZ_shipping
				                max = global_var:global_caribbean_tradezone.SHIPPING_total_in_TZ
				                divide = CURRENCY_power_TZ_penetration_score_modifier
				        }
				}
				add = { 
				        value = var:TZ_penetration_west_south_america
				        multiply = {
				                value = global_var:global_west_south_america_tradezone.var:TZ_shipping
				                max = global_var:global_west_south_america_tradezone.SHIPPING_total_in_TZ
				                divide = CURRENCY_power_TZ_penetration_score_modifier
				        }
				}
				add = { 
				        value = var:TZ_penetration_east_south_america
				        multiply = {
				                value = global_var:global_east_south_america_tradezone.var:TZ_shipping
				                max = global_var:global_east_south_america_tradezone.SHIPPING_total_in_TZ
				                divide = CURRENCY_power_TZ_penetration_score_modifier
				        }
				}
				add = { 
				        value = var:TZ_penetration_south_east_asia
				        multiply = {
				                value = global_var:global_south_east_asia_tradezone.var:TZ_shipping
				                max = global_var:global_south_east_asia_tradezone.SHIPPING_total_in_TZ
				                divide = CURRENCY_power_TZ_penetration_score_modifier
				        }
				}
				add = { 
				        value = var:TZ_penetration_indo_china
				        multiply = {
				                value = global_var:global_indo_china_tradezone.var:TZ_shipping
				                max = global_var:global_indo_china_tradezone.SHIPPING_total_in_TZ
				                divide = CURRENCY_power_TZ_penetration_score_modifier
				        }
				}
				add = { 
				        value = var:TZ_penetration_yellow_sea
				        multiply = {
				                value = global_var:global_yellow_sea_tradezone.var:TZ_shipping
				                max = global_var:global_yellow_sea_tradezone.SHIPPING_total_in_TZ
				                divide = CURRENCY_power_TZ_penetration_score_modifier
				        }
				}
				add = { 
				        value = var:TZ_penetration_southern_africa
				        multiply = {
				                value = global_var:global_southern_africa_tradezone.var:TZ_shipping
				                max = global_var:global_southern_africa_tradezone.SHIPPING_total_in_TZ
				                divide = CURRENCY_power_TZ_penetration_score_modifier
				        }
				}
				add = { 
				        value = var:TZ_penetration_west_africa
				        multiply = {
				                value = global_var:global_west_africa_tradezone.var:TZ_shipping
				                max = global_var:global_west_africa_tradezone.SHIPPING_total_in_TZ
				                divide = CURRENCY_power_TZ_penetration_score_modifier
				        }
				}
				add = { 
				        value = var:TZ_penetration_east_africa
				        multiply = {
				                value = global_var:global_east_africa_tradezone.var:TZ_shipping
				                max = global_var:global_east_africa_tradezone.SHIPPING_total_in_TZ
				                divide = CURRENCY_power_TZ_penetration_score_modifier
				        }
				}
				add = { 
				        value = var:TZ_penetration_middle_east
				        multiply = {
				                value = global_var:global_middle_east_tradezone.var:TZ_shipping
				                max = global_var:global_middle_east_tradezone.SHIPPING_total_in_TZ
				                divide = CURRENCY_power_TZ_penetration_score_modifier
				        }
				}
				add = { 
				        value = var:TZ_penetration_western_steppe
				        multiply = {
				                value = global_var:global_western_steppe_tradezone.var:TZ_shipping
				                max = global_var:global_western_steppe_tradezone.SHIPPING_total_in_TZ
				                divide = CURRENCY_power_TZ_penetration_score_modifier
				        }
				}
				add = { 
				        value = var:TZ_penetration_eastern_steppe
				        multiply = {
				                value = global_var:global_eastern_steppe_tradezone.var:TZ_shipping
				                max = global_var:global_eastern_steppe_tradezone.SHIPPING_total_in_TZ
				                divide = CURRENCY_power_TZ_penetration_score_modifier
				        }
				}
				add = { 
				        value = var:TZ_penetration_upper_yangtzi
				        multiply = {
				                value = global_var:global_upper_yangtzi_tradezone.var:TZ_shipping
				                max = global_var:global_upper_yangtzi_tradezone.SHIPPING_total_in_TZ
				                divide = CURRENCY_power_TZ_penetration_score_modifier
				        }
				}
				add = { 
				        value = var:TZ_penetration_atlantic_seaboard
				        multiply = {
				                value = global_var:global_atlantic_seaboard_tradezone.var:TZ_shipping
				                max = global_var:global_atlantic_seaboard_tradezone.SHIPPING_total_in_TZ
				                divide = CURRENCY_power_TZ_penetration_score_modifier
				        }
				}
				add = { 
				        value = var:TZ_penetration_central_europe
				        multiply = {
				                value = global_var:global_central_europe_tradezone.var:TZ_shipping
				                max = global_var:global_central_europe_tradezone.SHIPPING_total_in_TZ
				                divide = CURRENCY_power_TZ_penetration_score_modifier
				        }
				}
				add = { 
				        value = var:TZ_penetration_west_mediterranean
				        multiply = {
				                value = global_var:global_west_mediterranean_tradezone.var:TZ_shipping
				                max = global_var:global_west_mediterranean_tradezone.SHIPPING_total_in_TZ
				                divide = CURRENCY_power_TZ_penetration_score_modifier
				        }
				}
				add = { 
				        value = var:TZ_penetration_baltic
				        multiply = {
				                value = global_var:global_baltic_tradezone.var:TZ_shipping
				                max = global_var:global_baltic_tradezone.SHIPPING_total_in_TZ
				                divide = CURRENCY_power_TZ_penetration_score_modifier
				        }
				}
				add = { 
				        value = var:TZ_penetration_east_europe
				        multiply = {
				                value = global_var:global_east_europe_tradezone.var:TZ_shipping
				                max = global_var:global_east_europe_tradezone.SHIPPING_total_in_TZ
				                divide = CURRENCY_power_TZ_penetration_score_modifier
				        }
				}
				add = { 
				        value = var:TZ_penetration_east_mediterranean
				        multiply = {
				                value = global_var:global_east_mediterranean_tradezone.var:TZ_shipping
				                max = global_var:global_east_mediterranean_tradezone.SHIPPING_total_in_TZ
				                divide = CURRENCY_power_TZ_penetration_score_modifier
				        }
				}
			}
			
			multiply = TRADE_national_income
			#divide = var:official_currency.var:CURRENCY_num_adopters
		}
	}

	min = 0
}

CURRENCY_power_TZ_penetration_score_modifier = {
	value = 1000
}

CURRENCY_power_trade_bonus = {
	# Scope: Province (currency obj)
	# Function: Get the % discount in wealth cost of all imports from your currency value
	# Value is the percentage of your currency power out of all the world's currency powers
	value = 0
	if = {
		limit = {
			has_variable = CURRENCY_power_cached
		}
		value = {
			value = var:CURRENCY_power_cached
			divide = {
				every_province = {
					limit = {
						has_variable = currency_name
					}
					add = var:CURRENCY_power_cached
				}
				min = 1
			}
		}
	}
	multiply = 0.5
}


CURRENCY_power_trade_bonus_cached = {
	# Scope: Country
	if = {
		limit = {
			has_variable = official_currency
		}
		if = {
			limit = {
				var:official_currency = { 
					has_variable = CURRENCY_power_trade_bonus_cached
				}
			}
			value = var:official_currency.var:CURRENCY_power_trade_bonus_cached
		}
		else = {
			value = var:official_currency.CURRENCY_power_trade_bonus
		}
	}
	else = {
		value = 0
	}
	
}

CURRENCY_can_afford_debt_repayment_1k = {
	# Scope: Country
	# Function: Is greater than 0 if the cost of repaying debt would not put the country in a wealth deficit of >1,000
	value = treasury
	add = 1000
	add = CURRENCY_debt_wealth_value_1k_units_negative
	add = CURRENCY_repay_debt_1k_interest_cost
}

CURRENCY_can_afford_debt_repayment_10k = {
	# Scope: Country
	# Function: Is greater than 0 if the cost of repaying debt would not put the country in a wealth deficit of >1,000
	value = treasury
	add = 1000
	add = CURRENCY_debt_wealth_value_10k_units_negative
	add = CURRENCY_repay_debt_10k_interest_cost
}

CURRENCY_can_afford_debt_repayment_100k = {
	# Scope: Country
	# Function: Is greater than 0 if the cost of repaying debt would not put the country in a wealth deficit of >1,000
	value = treasury
	add = 1000
	add = {
		value = CURRENCY_debt_wealth_value_10k_units_negative
		multiply = 10
	}
	add = {
		value = CURRENCY_repay_debt_10k_interest_cost
		multiply = 10
	}
}

CURRENCY_can_afford_debt_repayment_1m = {
	# Scope: Country
	# Function: Is greater than 0 if the cost of repaying debt would not put the country in a wealth deficit of >1,000
	value = treasury
	add = 1000
	add = {
		value = CURRENCY_debt_wealth_value_10k_units_negative
		multiply = 100
	}
	add = {
		value = CURRENCY_repay_debt_10k_interest_cost
		multiply = 100
	}
}

CURRENCY_can_afford_pi_national_debt_1m = {
	value = political_influence
    add = CURRENCY_debt_issue_political_influence_cost_1m
    add = 100
}

CURRENCY_can_afford_pi_national_debt_100k = {
	value = political_influence
    add = CURRENCY_debt_issue_political_influence_cost_100k
    add = 100
}

CURRENCY_can_afford_pi_national_debt_10k = {
	value = political_influence
    add = CURRENCY_debt_issue_political_influence_cost_10k
    add = 100
}

CURRENCY_can_afford_pi_national_debt_1k = {
	value = political_influence
    add = CURRENCY_debt_issue_political_influence_cost_1k
    add = 100
}