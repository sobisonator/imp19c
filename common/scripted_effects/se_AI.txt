## AI Behaviour scripts

# DIPLOMACY

### Testing commands (for use in explorer)

### Behaviour script

#### WAR

AI_pick_war_target = {
	# Scope: Country
	# Function: Pick the country which the AI is most likely to declare war on

	#random_country = {
	#	weight = {
#
#			modifier = {
#
#			}
#
#		}
#	}
}

#### DIPLOMATIC REASONING
# Mark out rivals
# There are different types of rivals depending on the balance of power
# The greater a country's power rating, the more rivals it can have

# RIVAL TYPES:
# Oppose - country should confront this rival head-on as a fight between equals
# Fear - country should seek the help of stronger nations against this rival 
# Domineer - Country should subsume this rival into their empire or sphere of influence
# Subvert - Country should knock down this rival's power

AI_add_rival = {

}

#### DIPLOMATIC INTEREST
# Mark areas as "interests" to control

AI_add_control_interest_all_countries_limited = {
	# Scope: Any
	# Function: Generate diplomatic interests for all countries above the threshhold
	# Normally, diplomatic interests should be generated ad-hoc for countries rather than all at once
	# Especially as this is a relatively demanding script in terms of performance
	every_country = {
		limit = {
			DIPLOMACY_power > AI_diplomacy_interest_cutoff_threshhold
		}
		AI_add_control_interest = yes
	}
}

AI_add_control_interest = {
	# Scope: Country
	# Function: Pick an area to mark as an interest and add it to the list in country scope
	# AI interests are areas that the AI will focus on accessing diplomatically
	# Methods of control include controlling the land directly or through a subject
	# TODO: Store a list of recently "blocked" interests, where the AI has either satisfied its goal or has been stopped and will look to try elsewhere
	#
	# Notes:
	# AI countries without interests as defined here will pick activities based on a much simpler decision tree based
	# e.g. "control pops of my culture and religion", or "control claims"
	# Local powers will also react to plays in their TZ differently, acting more protectively.

	save_scope_as = AI_root

	ordered_area = {
		limit = {

			NOT = { THIS = area:spare_state }
			# Limits based on any area in the province
			any_area_province = {

				# Must have land not owned by AI_root or its vassals
				trigger_if = {
					limit = {
						has_owner = yes
					}
					NOT = { owner = scope:AI_root }
					trigger_if = {
						limit = {
							owner = {
								is_subject = yes
							}
						}
						NOT = { owner.overlord = scope:AI_root }
					}
				}
				

				# Adjacency required if AI_root is landlocked
				trigger_if = {
					limit = {
						scope:AI_root = {
							NOT = {
								any_owned_province = {
									is_coastal = yes
								}
							}
						}
					}
					any_neighbor_province = {
						owner = scope:AI_root
					}
				}

				# Only select coastal areas for overseas interests
				trigger_if = {
					limit = {
						NOT = {
							any_neighbor_province = {
								owner = scope:AI_root
							}
						}
					}
					is_coastal = yes
				}
				
			}
		}
		order_by = {
			value = {
				# Begin order_by value

				# BEGIN Values from provinces
				every_area_province = {
					limit = {
						trigger_if = {
							limit = {
								has_owner = yes
							}
							NOT = { owner = scope:AI_root }
							trigger_if = {
								limit = {
									owner = { is_subject = yes}
								}
								NOT = { owner.overlord = scope:AI_root }
							}
						}
					}
					# BEGIN FROM POPS
					add = {
						every_pops_in_province = {
							# Same religion
							if = {
								limit = {
									THIS.religion = scope:AI_root.religion
								}
								add = {
									value = scope:AI_root.SPIRIT_piety
									multiply = 2
								}
							}
							# Same culture
							if = {
								limit = {
									THIS.culture = scope:AI_root.culture
								}
								add = scope:AI_root.SPIRIT_nationalism
								multiply = 8
							}
							# Similar culture
							else_if = {
								limit = {
									THIS.culture_group = scope:AI_root.culture.culture_group
								}
								add = {
									value = scope:AI_root.SPIRIT_nationalism
									multiply = 5
								}
							}
						}
						multiply = 5
					}
					
					# END FROM POPS

					# Bonus from



					if = {
						limit = {
							has_owner = yes
						}
						if = {
							limit = {
								owner.religion = scope:AI_root.religion
								owner = { is_subject = no }
							}
							subtract = scope:AI_root.SPIRIT_piety
						}
						if = {
							limit = {
								owner.culture = scope:AI_root.culture
								owner = { is_subject = no }
							}
							subtract = scope:AI_root.SPIRIT_nationalism
						}
						else_if = {
							limit = {
								owner.culture_group = scope:AI_root.culture_group
								owner = { is_subject = no }
							}
							subtract = {
								value = scope:AI_root.SPIRIT_nationalism
								min = 0.01
								divide = 2
							}
						}
					}
					# Tradegood desirability
					# TODO: Balance the weighting, as expensive goods are far too preferred, owning them as a small country would basically be a death wish
					# Maybe get square root of tradegood price to diminish the distribution of prices in this calculation
					# Or a little weighting from the actual num goods produced
					# Alternatively, from the total possible building slots or population cap?
					add = AI_interest_weighting_from_tradegood
					# Add how much population the province can support
					# TODO: This is not working as intended, it should be higher for terrains that can support more pops
					# Encouraged to predate on low industrialisation provinces
					subtract = {
						value = civilization_value
						multiply = 20
					}
					# Discouraged coveting overlord's territory
					if = {
						limit = {
							has_owner = yes
						}
						if = {
							limit = {
								owner = scope:AI_root.overlord
							}
							subtract = 1000
						}
					}
					# Add value from intrinsic shipping modifiers (instead of adding raw shipping power, because AI interest is more about the potential of an area than its current value)
					if = {
						limit = {
							has_variable = natural_harbour
						}
						add = {
							value = SHIPPING_natural_harbour_bonus
							multiply = 10
						}
					}
					if = {
						limit = {
							has_variable = major_estuary
						}
						add = {
							value = SHIPPING_major_estuary_bonus
							multiply = 10
						}
					}
					if = {
						limit = {
							has_variable = trade_chokepoint
						}
						add = {
							value = SHIPPING_trade_chokepoint_bonus
							multiply = 10
						}
					}
					if = {
						limit = {
							has_minor_river = yes
						}
						add = {
							value = SHIPPING_river_or_coast_bonus
							multiply = 10
						}
					}
					# Discourage coveting allies' territory
					if = {
						limit = {
							has_owner = yes
						}
						if = {
							limit = {
								OR = {
									owner = {
										alliance_with = scope:AI_root
									}
									trigger_if = {
										limit = {
											owner = { is_subject = yes }
										}
										owner.overlord = {
											OR = {
												alliance_with = scope:AI_root
												is_subject_of = scope:AI_root
											}
										}
									}
								}
							}
							value = 1
						}
					}
					# Triple the entire province score if this province is a claim of the AI_root
					if = {
						limit = {
							is_core_of = scope:AI_root
						}
						multiply = 3
					}
				}
				# END provinces loop
				# Boost the score per province
				multiply = 5
				# Turn this into an average province value for the area, so the bias is not towards purely larger areas
				divide = {
					every_area_province = {
						limit = {
							trigger_if = {
								limit = {
									has_owner = yes
								}
								NOT = { owner = scope:AI_root }
								trigger_if = {
									limit = {
										owner = { is_subject = yes }
									}
									NOT = { owner.overlord = scope:AI_root }
								}
							}
						}
						add = 0
					}
					min = 1
				}
				# END Values from provinces

				# From neighbouring areas if port ratio is low
				if = {
					limit = {
						any_area_province = {
							any_neighbor_province = {
								trigger_if = {
									limit = {
										has_owner = yes
									}
									OR = {
										owner = scope:AI_root
										owner = { is_subject_of = scope:AI_root }
									}
								}
								
							}
						}
					}
					divide = {
						value = AI_ports_to_land_ratio
						min = 0.01
					}
				}
				
				# From AI_root's DIPLOMACY_power in the area's TZ
				multiply = AI_diplomacy_interest_from_tradezone_diplomacy_power_scope_ai_root
				# TODO: Try adding half the diplomacy power of AI_root from neighbouring TZs as well
				 
				# Add weight if AI_root is not a major player in the TZ, but it aspires to be.
				# End order_by value
			}
		}

		max = {
			value = scope:AI_root.DIPLOMACY_power
			divide = AI_diplomacy_interest_cutoff_threshhold
			divide = 20
			round = floor
			min = 1
		}
		check_range_bounds = no

		# Currently here for testing - this is so that the tooltip can grab province area by scoping to a state
		random_area_province = {
			save_scope_as = AI_interest_target
		}


		scope:AI_root = {
			if = {
				limit = {
					NOR = {
						is_target_in_variable_list = {
							name = AI_interests_list
							target = scope:AI_interest_target
						}
						any_in_list = {
							variable = AI_interests_list

							THIS.area = scope:AI_interest_target.area
						}
					}
				}
				add_to_variable_list = {
					name = AI_interests_list
					target = scope:AI_interest_target
				}
			}
		}
		
	}

	# TESTING PURPOSES ONLY - Saves just 1 interest var
	set_variable = {
		name = AI_interest
		value = scope:AI_interest_target
	}

}

AI_begin_diplomatic_play = {
	# Scope: Country (instigator of the play)
	# Function: Begin a diplomatic play in an interest
	# Activities may be aimed at the area in general with no particular diplomatic target
	# OR
	# If multiple countries own territory in the area, the AI_root is most likely to engage diplomatically with the country which owns the most valuable province 
	# Province value = (tradegood output x tradegood value) + shipping power

	# Diplomatic plays may range from requesting a treaty for access to an area
	# To outright wars of conquest or espionage missions to subvert control of a rival

	# The play may range from controlling the area, to the whole region, to possibly the whole of a country which controls that area, depending on the relative strength of that country. For example, if a relatively low power country controls an area, the AI_root may target that entire control for control.

	# We begin by creating a provobj
	every_in_list = {
		list = local_great_powers
		remove_from_list = local_great_powers
	}
		
	every_in_list = {
		list = play_targets
		remove_from_list = play_targets
	}
	random_province = {
		limit = {
			NOT = {
				has_variable = is_diplomatic_play # We don't want to overwrite an existing object with this, so be sure to pick an unused province
			}
		}
		set_variable = is_diplomatic_play
		save_scope_as = diplomatic_play

		set_variable = {
			name = play_instigator
			value = $play_instigator$ # Must be a country.
		}
		set_variable = {
			name = play_target_area
			value = $play_target_area$ # Must be a province.
			# if no area is targeted, this must have value of a province in area:spare_state
			# This var is for when the play is about a particular piece of land, rather than a country
		}
		set_variable = {
			name = play_target_country
			value = $play_target_country$ # Must be a country.
			# if no country is targeted, this must be the same as the instigator
			# This var is for when the play is not about any particular piece of land, but about an entire country
		}
		set_variable = {
			name = play_goal # The goal that the AI_root wants to achieve with this diplomatic play
			value = $play_goal$ # Available options below
			# flag:get_territory
			# flag:install_friendly_government
		}
		set_variable = {
			name = play_infamy_cost_war # How much infamy (AE) is gained from declaring war. Represents the international disapproval of resolving the play militarily. This is a starting value which is modified by events and play actions
			value = {
				value = 100
				subtract = {
					var:play_target_area.area = {
						every_area_province = {
							if = {
								limit = {
									is_core_of = scope:diplomatic_play.var:play_instigator
								}
								add = 75
							}
							subtract = { # Less infamy from attacking backwaters
								# More from attacking industralised areas
								value = civilization_value
								multiply = 2
							}
							# If the owner is a great power, increase the cost
							if = {
								limit = {
									has_owner = yes
								}
								if = {
									limit = {
										OR = {
											any_in_global_list = {
												variable = global_powers_list
												THIS = PREV.owner
											}
											trigger_if = {
												limit = {
													owner = { 
														is_subject = yes
														NOT = { is_subject_type = tributary }
														NOT = { is_subject_type = sinosphere_tributary }
													}
												}
												any_in_global_list = {
													variable = global_powers_list
													THIS = PREV.owner.overlord
												}
											}
										}
									}
									subtract = 30
								}
							}
						}
					}
					divide = {
						var:play_target_area.area {
							every_area_province = {
								add = 1
							}
						}
						min = 1
					}
				}
				min = 0
			}
		}
		set_variable = {
			name = play_stability_cost_war # How much stability is lost from declaring war. Represents the public support for a war over this play. This is a starting value which is modified by events and play actions
			value = {
				value = 50
				subtract = {
					var:play_target_area.area = {
						every_area_province = {
							if = {
								limit = {
									is_core_of = scope:diplomatic_play.var:play_instigator
								}
								add = 75
							}
							if = {
								limit = {
									trigger_if = {
										limit = {
											has_owner = yes
										}
										NOT = { 
											owner.culture = scope:diplomatic_play.var:play_instigator.culture 
										}
									}
									
								}
								every_pops_in_province = {
									if = {
										limit = {
											culture = scope:diplomatic_play.var:play_instigator.culture
										}
										add = 2
									}
									if = {
										limit = {
											culture.culture_group = scope:diplomatic_play.var:play_instigator.culture.culture_group
										}
										add = 1
									}
								}
							}
						}
					}
					divide = {
						var:play_target_area.area {
							every_area_province = {
								add = 1
							}
						}
						min = 1
					}
				}
				min = 1
			}
		}

		# Now add this diplomatic play to the list of diplomatic plays in progress in the instigator
		# And assess the targets
		add_to_variable_list = {
			name = list_of_diplomatic_plays_instigated
			target = scope:diplomatic_play
		}
		add_to_global_variable_list = {
			name = global_all_diplomatic_plays
			target = scope:diplomatic_play
		}

		scope:diplomatic_play = {
			if = {
				limit = {
					has_variable = play_target_area
				}
				AI_assess_all_adversaries = {
					diplomatic_play = scope:diplomatic_play
				}
			}
		}
		ordered_in_list = {
			list = play_targets
			order_by = var:play_target_rating

			if = {
				limit = {
					NOT = { THIS = scope:diplomatic_play.var:play_instigator }
				}
				save_scope_as = play_target_country_scope
				scope:diplomatic_play = {
					set_variable = {
						name = play_target_country
						value = scope:play_target_country_scope
					}
				}
			}

			max = 1 # Select only the best one
			check_range_bounds = no
		}
		every_in_list = {
			list = play_targets
			remove_from_list = play_targets
		}

		# SUPPORTERS:
		# Now that the country target has been selected, create lists for supporters
		# Regional powers (i.e. countries with great power status in the interest area's tradezone)
		# are allowed to pick a side, or sit on the fence, to mediate the play

		# Get all great powers in this TZ
		scope:diplomatic_play = {
			if = {
				limit = {
					has_variable = play_target_area
				}
				scope:diplomatic_play.var:play_target_area.area.region = {
					random_region_province = {
						limit = {
							has_owner = yes
						}
						governorship.var:trade_center = {
							var:DIPLOMACY_power_n1 = { add_to_list = local_great_powers }
							var:DIPLOMACY_power_n2 = { add_to_list = local_great_powers }
							var:DIPLOMACY_power_n3 = { add_to_list = local_great_powers }
							var:DIPLOMACY_power_n4 = { add_to_list = local_great_powers }
						}
					}
				}
			}
		}
		
		every_in_list = {
			list = local_great_powers

			save_scope_as = play_observer

			if = {
				limit = {
					OR = {
						scope:play_observer = scope:diplomatic_play.var:play_instigator
						AND = {
							scope:play_observer.overlord = scope:diplomatic_play.var:play_instigator
							NOT = {
								scope:play_observer = {
									OR = {
										is_subject_type = tributary
										is_subject_type = sinosphere_tributary
									}
								}
							}
						}
					}
				}
				scope:diplomatic_play = {
					add_to_variable_list = {
						name = play_observers_support_instigator
						target = scope:play_observer
					}
				}
			}
			else_if = {
				limit = {
					OR = {
						trigger_if = {
							limit = {
								scope:diplomatic_play.var:play_target_country = { is_subject = yes }
							}
							scope:play_observer = scope:diplomatic_play.var:play_target_country.overlord
							trigger_if = {
								limit = {
									scope:diplomatic_play.var:play_target_country.overlord = { is_subject = yes }
								}
								scope:play_observer = scope:diplomatic_play.var:play_target_country.overlord.overlord
							}
						}
						scope:play_observer = scope:diplomatic_play.var:play_target_country
					}
				}
				scope:diplomatic_play = {
					add_to_variable_list = {
						name = play_observers_support_target
						target = scope:play_observer
					}
				}
			}
			else = {
				scope:diplomatic_play = {
					add_to_variable_list = {
						name = play_observers_undecided
						target = scope:play_observer
					}
				}
			}
		}

		# Empty list for play_supporters_instigator

		# Empty list for play_supporters_target
	}

}

AI_assess_all_adversaries = {
	# Scope: Province (Diplomatic play)
	# Function: Get all the adversaries in an area and assess them using AI_assess_adversary

	every_in_list = {
		list = adversaries_to_assess
		remove_from_list = adversaries_to_assess
	}

	$diplomatic_play$ = { save_scope_as = diplomatic_play }

	if = {
		limit = {
			always = yes
		}
		scope:diplomatic_play.var:play_target_area.area = {
			every_area_province = {
				limit = {
					has_owner = yes
					trigger_if = {
						limit = {
							has_owner = yes
						}
						NOT = { owner = scope:diplomatic_play.var:play_instigator }
						trigger_if = {
							limit = {
								owner = { is_subject = yes }
							}
							NOT = { owner.overlord = scope:diplomatic_play.var:play_instigator }
						}
						owner = {
							OR = {
								any_owned_province = { is_coastal = yes }
								any_owned_province = { 
									any_neighbor_province = { 
										owner = scope:diplomatic_play.var:play_instigator 
									} 
								}
							}
						}
					}
				}
				owner = {
					add_to_list = adversaries_to_assess
				}
			}
		}
	}
	
	

	every_in_list = {
		list = adversaries_to_assess

		save_scope_as = AI_target

		AI_assess_adversary = {
			AI_target = scope:AI_target
			diplomatic_play = scope:diplomatic_play
		}
	}
}

AI_remove_diplomatic_play = {
	# Scope: Province (diplomatic play object)
	# Function: Delete a diplomatic play
	save_scope_as = play_to_delete
	if = {
		limit = {
			has_variable = play_instigator
		}
		var:play_instigator = {
			remove_list_variable = {
				name = list_of_diplomatic_plays_instigated
				target = scope:play_to_delete
			}
		}
	}
	remove_list_global_variable = {
		name = global_all_diplomatic_plays
		target = THIS
	}
	remove_variable = is_diplomatic_play
	remove_variable = play_instigator
	remove_variable = play_target_area
	remove_variable = play_target_country
	remove_variable = play_goal
	clear_variable_list = play_observers_support_instigator
	clear_variable_list = play_observers_support_target
	clear_variable_list = play_observers_undecided
}

AI_debug_test_begin_diplomatic_play_all = {
	# Scope: Any
	# Function: Test assess adversary on all countries with an interest

	# First, delete all diplomatic plays
	every_in_list = {
		list = local_great_powers
		remove_from_list = local_great_powers
	}

	every_in_global_list = {
		variable = global_all_diplomatic_plays
		AI_remove_diplomatic_play = yes
	}

	every_country = {
		clear_variable_list = AI_interests_list
	}
	every_country = {
		save_scope_as = from
		every_in_list = {
			variable = AI_interests_list
			save_scope_as = remove
			scope:from = {
				remove_list_variable = {
					name = AI_interests_list
					target = scope:remove
				}
			}
			
		}
	}

	AI_add_control_interest_all_countries_limited = yes
	every_country = {
		limit = {
			has_variable = AI_interest
		}
		save_scope_as = AI_root
		every_in_list = {
			variable = AI_interests_list
			save_scope_as = target_area
			AI_begin_diplomatic_play = {
				play_instigator = scope:AI_root
				play_target_area = scope:target_area
				play_target_country = scope:AI_root # No specific country
				play_goal = flag:get_territory
			}
		}
	}
	every_province = {
		limit = {
			has_variable = is_diplomatic_play
		}
		AI_diplomatic_play_evaluate_attitude = {
			diplomatic_play = THIS
		}
		AI_diplomatic_play_evaluate_war = {
			diplomatic_play = THIS
		}
	}
}

AI_assess_adversary = {
	# Scope: Country (AI_target)
	# Function: Assess the $AI_target$ country from the perspective of AI_root
	# This helps the AI determine whether it should:
	# - Try to annex the target (holds core land and is small)
	# - Try to vassalise the target (is small)
	# - Try to vassalise the target and move on to others (is tiny)
	# - Try to take land directly from the target (is big and holds core land)
	# - Try to give land to an ally or new vassal (is big and holds non-core land)

	# Also essential for determining diplomatic parity (i.e. comparing diplomatic power scores)
	# Diplomatic parity determines how much pressure root can put on target
	# Or if parity is imbalanaced, root will seek more support before putting pressure on
	# This gives the root a pressure "budget" which it can spend on triggering actions in script
	# Some actions "cost" less pressure to do and will therefore be more attractive to countries that are more on-par, or where root is less powerful than target

	# Target can also seek support to gain power, but only in subsequent stages of a diplomatic play, where assessments are repeated but by both sides of the play.

	# Mark the level of risk by the total power between the two sides


	#######################
	every_in_list = {
		list = play_assessed_already
		remove_from_list = play_assessed_already
	}
	# Save the current target in a scope
	$diplomatic_play$.var:play_instigator = { save_scope_as = AI_root }
	save_scope_as = AI_target


	# Get own target Diplomatic power
	set_local_variable = {
		name = AI_root_power
		value = {
			value = scope:AI_root.DIPLOMACY_power
		}
	}
	scope:AI_root = { add_to_list = play_assessed_already }

	scope:AI_root = {
		every_allied_country = {
			# Add less if allied with the target
			save_scope_as = test_ally
			if = {
				limit = {
					$AI_target$ = {
						any_allied_country = {THIS = scope:test_ally}
					}
				}
				change_local_variable = {
					name = AI_root_power
					add = {
						value = THIS.DIPLOMACY_power
						multiply = 0.2
					}
				}
			}
			else = {
				change_local_variable = {
					name = AI_root_power
					add = {
						value = THIS.DIPLOMACY_power
						multiply = 0.5
					}
				}
			}
			add_to_list = play_assessed_already
		}
	}

	# Get target's Diplomatic power
	# Plus power of their allies
	set_local_variable = {
		name = AI_target_power
		value = {
			value = $AI_target$.DIPLOMACY_power
		}
	}
	$AI_target$ = {
		every_allied_or_guaranteeing_country = {
			# Add less if allied with the target
			save_scope_as = test_ally
			if = {
				limit = {
					scope:AI_root = {
						any_allied_country = {THIS = scope:test_ally}
					}
				}
				change_local_variable = {
					name = AI_target_power
					add = {
						value = THIS.DIPLOMACY_power
						multiply = 0.5
					}
				}
			}
			else = {
				change_local_variable = {
					name = AI_target_power
					add = {
						value = THIS.DIPLOMACY_power
						multiply = 0.7
					}
				}
			}
			add_to_list = play_assessed_already
		}
		if = {
			limit = {
				is_subject = yes
				NOT = {
					is_subject_type = tributary # Tributaries do not get protected in wars
					is_subject_type = sinosphere_tributary
				}
			}
			overlord = {
				change_local_variable = {
					name = AI_target_power
					add = {
						value = THIS.DIPLOMACY_power
					}
				}
				add_to_list = play_assessed_already
			}
		}
	}
	
	# Calculate the power balance
	# Positive value = balance in favour of the instigator
	# Negative value = balance in favour of the target
	$diplomatic_play$ = {

		every_in_list = {
			variable = play_observers_support_target
			limit = {
				NOT = { is_in_list = play_assessed_already }
			}
			change_local_variable = {
				name = AI_target_power
				add = THIS.DIPLOMACY_power
			}
		}
		every_in_list = {
			variable = play_observers_support_instigator
			limit = {
				NOT = { is_in_list = play_assessed_already }
			}
			change_local_variable = {
				name = AI_root_power
				add = THIS.DIPLOMACY_power
			}
		}

		set_variable = {
			name = AI_play_power_balance_instigator_root
			value = {
				value = {
					value = local_var:AI_root_power
					divide = 100
				}
				divide = {
					value = local_var:AI_target_power
					min = 1
					divide = 100
				}
			}
		}
	}

	# DEBUG ONLY
	# Save the power balance and target country to vars in the instigator scope
	scope:AI_root = {
		set_variable = {
			name = DEBUG_diplomatic_play
			value = $diplomatic_play$
		}
	}

	# Now add the AI_target to the right list in the diplomatic play so the instigator can decide how to treat them.
	$diplomatic_play$ = {
		if = {
			limit = {
				var:AI_play_power_balance_instigator_root > 1000
			}
		}
	}
	set_variable = {
		name = play_target_rating # Higher value = easier to eat
		value = $diplomatic_play$.var:AI_play_power_balance_instigator_root
		days = 1
	}
	add_to_list = play_targets
}

### AI Behaviour in diplomatic plays

#### Regional great powers: choosing sides
# Great powers (let's call it observer_root) will oppose a play if another great power is making a play for an area in the same region where observer_root, or one of its subjects, also owns land

# WAR

### Declare war

AI_diplomatic_play_evaluate_attitude = {
	# Scope: Country
	# Function: Evaluate whether the AI should act in a friendly way or a hostile way towards the target
	# Do their interests align
	# Takes a diplomatic play province as argument
	$diplomatic_play$ = { save_scope_as = diplomatic_play }

	scope:diplomatic_play = {
		set_local_variable = {
			name = AI_friendly
			value = {
				value = 0
				if = {
					limit = {
						var:play_target_country.religion = var:play_instigator.religion
					}
					add = 50
				}
				if = {
					limit = {
						var:play_target_country.culture = var:play_instigator.culture
					}
					add = 50
				}

			}
		}
		set_local_variable = {
			name = AI_hostile
			value = {
				value = 0
				add = {
					value = var:AI_play_power_balance_instigator_root # Higher balance of power = likelier to be aggressive
				}
				var:play_target_area.area = {
					every_area_province = {
						limit = {
							is_core_of = scope:diplomatic_play.var:play_instigator
						}
						add = 20
					}
				}
			}
		}

		set_variable = {
			name = AI_play_attitude
			value = {
				add = local_var:AI_friendly
				subtract = local_var:AI_hostile
			}
		}
	}
}

AI_diplomatic_play_evaluate_course_of_hostile_action = {
	# Scope: Country
	# Function: If hostile, determine whether the AI should seek to get the land handed to an ally, a subject, or take it for itself
}

AI_diplomatic_play_evaluate_war = {
	# Scope: Any
	# Function: Evaluate whether it is worth starting a war for a diplomatic play this country instigated
	# Negative value = not worth
	# Positive value = worth, declare war
	# Takes a diplomatic play province as argument

	$diplomatic_play$ = { save_scope_as = diplomatic_play }

	scope:diplomatic_play = {
		set_local_variable = {
			name = AI_play_war_assessment
			value = {
				value = 0
				subtract = { 
					value = var:play_infamy_cost_war
					multiply = var:play_infamy_cost_war
				}
				subtract = {
					value = var:play_stability_cost_war
					multiply var:play_stability_cost_war
				}
				subtract = { # negative attitudes will encourage war
					value = var:AI_play_attitude
					multiply = var:AI_play_power_balance_instigator_root
				}
				var:play_instigator = {
					subtract = {
						value = has_war_exhaustion
						multiply = 120
						multiply = has_war_exhaustion
					}
					if = {
						limit = {
							stability < 50
						}
						subtract = {
							value = 50
							subtract = stability
							multiply = 500
						}
					}
					else = {
						add = stability
					}
					add = treasury
				}
				var:play_target_country = {
					add = {
						value = has_war_exhaustion
						multiply = 60
					}
					subtract = stability
				}
				if = {
					limit = {
						var:play_instigator_country = {
							has_truce_with = scope:diplomatic_play.var:play_target_country
						}
						subtract = 100000
					}
				}
			}
		}

		# A war with many huge powers on both sides is more costly, less likely to go ahead
		every_in_list = {
			variable = play_observers_support_target
			change_local_variable = {
				name = AI_play_war_assessment
				subtract = {
					value = THIS.DIPLOMACY_power
					multiply = 0.01
				}
			}
		}
		every_in_list = {
			variable = play_observers_support_instigator
			change_local_variable = {
				name = AI_play_war_assessment
				subtract = {
					value = THIS.DIPLOMACY_power
					multiply = 0.005
				}
			}
		}

		### DEBUG only - there is no reason to keep this variable
		set_variable = {
			name = war_assessment
			value = local_var:AI_play_war_assessment
		}

	}

}

AI_debug_test_war_all_diplomatic_plays = {
	every_province = {
		limit = {
			has_variable = is_diplomatic_play
			trigger_if = {
				limit = {
					has_variable = war_assessment
				}
				var:war_assessment > 0
			}
		}
		save_scope_as = diplomatic_play
		var:play_target_country = { save_scope_as = target_country }
		# Get the capital of the state in the target country
		var:play_target_area = {
			area = {
				random_area_province = {
					limit = {
						trigger_if = {
							limit = {
								has_owner = yes
							}
							owner = scope:diplomatic_play.var:play_target_country
						}
					}
					state.capital_scope = { save_scope_as = wargoal_target_province }
				}
			}
		}
		var:play_instigator = {
			FUNC_declare_war_with_wargoal_province = {
				war_goal = conquer_wargoal
				province = scope:wargoal_target_province
				target = scope:target_country
			}
		}
		
	}
}

### NOTES on scoping to a war
# Take this vanilla example
vanilla_war_scope_sample_effect = {
	random_current_war = {
		limit = {
			any_war_participant = { tag = MRY }
			any_war_participant = { this = root }
			is_war_leader = root
			is_war_leader = c:MRY
		}
		save_scope_as = seleuko_mauryan_war_scope
	}
}

AI_assess_peace = {
	# Scope: War
	# Function: Assess whether the AI countries in this war want to make peace
}

AI_make_peace_province_wishlist_p0 = {
	# Scope: War
	# Function: Trigger peace province wishlist script for every member of the war on the appropriate side
	set_global_variable = {
		name = total_warscore_cost_available
		value = 100 # Debug, it should be taken from the war scope
	}
	save_scope_as = war_scope

	if = {
		limit = {
			flag:$target$ = flag:defender
		}
		# TODO: Make the block below into a scripted effect so it's not repeated for each scenario
		set_global_variable = {
			name = total_diplomacy_power
			value = {
				every_war_attacker = {
					add = DIPLOMACY_power
				}
			}
		}
		ordered_war_attacker = {
			order_by = {
				value = DIPLOMACY_power
				multiply = -1
			}
			max = 999
			check_range_bounds = no
			save_scope_as = AI_root
			scope:war_scope = { AI_make_peace_province_wishlist = { target = $target$ } }
		}
	}
	else = {
		set_global_variable = {
			name = total_diplomacy_power
			value = {
				every_war_defender = {
					add = DIPLOMACY_power
				}
			}
		}
		ordered_war_defender = {
			save_scope_as = AI_root
			scope:war_scope = { AI_make_peace_province_wishlist = { target = $target$ } }
		}
	}
	remove_global_variable = total_diplomacy_power
	remove_global_variable = total_warscore_cost_available

}

AI_make_peace_province_wishlist = {
	# Scope: War
	# Function: Make a list of provinces the AI wants to demand in a peace deal
	# Should be run for every war participant so they can each put their wishlist forward for final demands
	# The wishlists should be saved as variable lists in each country, and destroyed once the peace resolution is complete
	# This shouldn't cause cross over between peace assessments, because the entire process should be concurrent from start to finish for each war, so the lists should be created and destroyed before any other wars are assessed for peace.
	# Takes argument $target$, which is either "attacker" or "defender"
	# It is the target, therefore this is run against the opposite side of the calling scope
	# If this is run from the perspective of the attacker, then it should be run on all defenders

	set_global_variable = {
		name = warscore_cost_available
		value = {
			value = global_var:total_warscore_cost_available
			multiply = {
				value = scope:AI_root.DIPLOMACY_power
				divide = global_var:total_diplomacy_power
			}
		}
	}

	every_in_list = {
		list = AI_peace_wishlist_stage_1
		remove_from_list = AI_peace_wishlist_stage_1
	}

	every_war_$target$ = {
		every_owned_province = {
			limit = {
				OR = {
					is_core_of = scope:AI_root
					trigger_if = {
						limit = {
							scope:AI_root = {
								any_owned_province = { is_coastal = yes }
							}
						}
						is_coastal = yes
					}
					any_neighbor_province = {
						has_owner = yes
						trigger_if = {
							limit = {
								has_owner = yes
							}
							owner = scope:AI_root
						}
					}
				}
			}
			add_to_list = AI_peace_wishlist_stage_1
		}
		every_owned_province = {
			# Provinces in states neighbouring the AI_root
			limit = {
				NOT = { is_in_list = AI_peace_wishlist_stage_1 }
				OR = {
					state = {
						any_state_province = {
							any_neighbor_province = {
								owner = scope:AI_root
							}
						}
					}
					
					# Or are part of a state with fewer than 45% inland provinces
					state.FUNC_state_coastal_ratio > 0.45
				}
			}
			add_to_list = AI_peace_wishlist_stage_1
			set_variable = {
				name = PEACE_requested_by # Needed to calculate warscore effects relative to the requestor
				value = scope:AI_root
			}
		}
	}
	# Add all provinces which are part of an AI interest state
	every_war_$target$ = {
		add_to_list = list_of_targets
	}
	scope:AI_root = {
		every_in_list = {
			variable = AI_interests_list
			area = {
				every_area_province = {
					limit = {
						owner = { is_in_list = list_of_targets }
					}
				}
			}
		}
	}
	every_in_list = {
		list = list_of_targets
		remove_from_list = list_of_targets
	}
	# Create a list of tradezones in AI_root, we'll need this later
	scope:AI_root = {
		every_governorships = {
			limit = {
				NOT = {
					var:trade_center = {
						is_in_list = tradezones_in_AI_root
					}
				}
			}
			var:trade_center = {
				add_to_list = tradezones_in_AI_root
			}
		}
	}
	# Now make a list of any target-owned tradezones
	every_war_$target$ = {
		every_governorships = {
			limit = {
				NOT = {
					var:trade_center = {
						is_in_list = tradezones_in_target
					}
				}
			}
			var:trade_center = {
				add_to_list = tradezones_in_target
			}
		}
	}
	# Now make a list of any target tradezones which match or neighbour tradezones in AI_root
	every_in_list = {
		list = tradezones_in_target
		save_scope_as = tradezone_checked
		if = {
			limit = {
				is_in_list = tradezones_in_AI_root
			}
			add_to_list = matching_neighbouring_tradezones
		}
		every_in_list = {
			variable = neighbouring_tradezones
			if = {
				limit = {
					is_in_list = tradezones_in_AI_root
				}
				scope:tradezone_checked = {
					add_to_list = matching_neighbouring_tradezones
				}
			}
		}
	}
	ordered_in_list = {
		list = AI_peace_wishlist_stage_1
		order_by = {
			value = AI_interest_value_province
			# Increase interest in gaining claims
			if = {
				limit = {
					is_core_of = scope:AI_root
				}
				multiply = 2
				add = 999999
			}
			# Reduce desirability of inland provinces without a contiguous border
			if = {
				limit = {
					is_coastal = no
					any_neighbor_province = {
						limit = {
							has_owner = yes
						}
						NOT = {
							owner = scope:AI_root
						}
					}
				}
				divide = 1 # Testing no extra impact from being inland
			}
			# Reduce desirability of ports without a contiguous border or nearby port
			if = {
				limit = {
					any_neighbor_province = {
						limit = {
							has_owner = yes
						}
						owner = scope:AI_root
					}
				}
				add = 10000
			}
			state = {
				if = {
					limit = {
						NOT = {
							any_state_province = {
								any_neighbor_province = {
									limit = {
										has_owner = yes
									}
									owner = scope:AI_root
								}
							}
						}
					}
					subtract = 10000
				}
			}
			# If is coastal and this region is not sharing a sea province with AI_root's land
			region = {
				if = {
					limit = {
						any_region_area = {
							any_area_province = {
								limit = {
									is_coastal = yes
								}
								any_neighbor_province = {
									limit = {
										is_sea = yes
									}
									any_neighbor_province = {
										limit = { 
											is_sea = no
										}
										any_neighbor_province = {
											limit = {
												is_coastal = yes
												has_owner = yes
											}
											owner = scope:AI_root
										}
									}
								}
							}
						}
					}
					add = 10000
				}
			}
			# Reduce the value of provinces not in neighbouring regions to countries with low naval power
			region = {
				if = {
					limit = {
						NOT = {
							any_region_province = {
								any_neighbor_province = {
									owner = scope:AI_root
								}
							}
						}
					}
					multiply = scope:AI_root.AI_coastal_port_states_power_ratio
				}
			}
			
			
			# TODO: Increased likelihood of landlocked countries seeking coastal provinces in neighbouring states
			subtract = {
				value = WARSCORE_province_value_AI_root_claim_discount
				multiply = 2
			}
			max = 999999
		}
		max = 9999
		check_range_bounds = no
		# Prevent the AI from taking provinces not in a shared or neighbouring tradezone to countries with low naval power
		if = {
			limit = {
				scope:AI_root.AI_coastal_port_states_power_ratio < 1
			}
			if = {
				limit = {
					NOT = {
						governorship.var:trade_center = {
							is_in_list = matching_neighbouring_tradezones
						}
					}
				}
				remove_from_list = AI_peace_wishlist_stage_1
			}
		}
		if = {
			limit = {
				trigger_if = {
					limit = {
						has_global_variable = warscore_cost_available
					}
					global_var:warscore_cost_available > WARSCORE_province_value_AI_root_claim_discount
				}
				
			}
			# Keep in the list
			change_global_variable = {
				name = warscore_cost_available
				subtract = WARSCORE_province_value_AI_root_claim_discount
			}
			set_variable = {
				name = debug_original_owner
				value = owner
			}
		}
		else = {
			remove_from_list = AI_peace_wishlist_stage_1
		}
		remove_variable = PEACE_requested_by # No longer needed as the deal is being concluded, warscore cost has already been calculated

		# Once all warscore cost has been used, remove all other provinces from the list
	}
	# Clean up tradezones list
	every_in_list = {
		list = tradezones_in_AI_root
		remove_from_list = tradezones_in_AI_root
	}
	every_in_list = {
		list = tradezones_in_target
		remove_from_list = tradezones_in_target
	}
	# Clean up for contiguousness and reasonable borders
	every_in_list = {
		list = AI_peace_wishlist_stage_1
		# Remove non-coastal isolated exclaves in non-OPMs
		if = {
			limit = {
				NOT = {
					any_neighbor_province = {
						is_in_list = AI_peace_wishlist_stage_1
					}
					owner = {
						num_of_provinces < 2
					}
					is_coastal = yes
				}
			}
			remove_from_list = AI_peace_wishlist_stage_1
			# Refund the warscore cost for use elsewhere
			change_global_variable = {
				name = warscore_cost_available
				add = WARSCORE_province_value_AI_root_claim_discount
			}
		}

		# Subsume inland enemy exclaves for clean borders
		every_neighbor_province = {
			limit = {
				is_coastal = no # inland
				NOT = { is_in_list = AI_peace_wishlist_stage_1 } # not already in the list
				NOT = { # No neighbor province is not already in the list
					# i.e., they are all in the list, so it is surrounded
					any_neighbor_province = {
						NOT = { is_in_list = AI_peace_wishlist_stage_1 }
					}
				}
			}
			add_to_list = AI_peace_wishlist_stage_1
		}
	}
	# Repeat the enemy exclaves cleanup and remove offshore provinces with no route to sea
	every_in_list = {
		list = AI_peace_wishlist_stage_1
		every_neighbor_province = {
			limit = {
				is_coastal = no # inland
				NOT = { is_in_list = AI_peace_wishlist_stage_1 } # not already in the list
				NOT = { # No neighbor province is not already in the list
					# i.e., they are all in the list, so it is surrounded
					any_neighbor_province = {
						NOT = { is_in_list = AI_peace_wishlist_stage_1 }
					}
				}
			}
			add_to_list = AI_peace_wishlist_stage_1
		}
		if = {
			limit = {
				is_coastal = no
				NOT = {
					any_neighbor_province = {
						trigger_if = {
							limit = {
								has_owner = yes
							}
							NOT = {
								owner = {
									war_with = scope:AI_root
								}
							}
						}
					}
				}
				region = {
					any_region_province = {
						trigger_if = {
							limit = {
								has_owner = yes
							}
							NOT = {
								any_neighbor_province = {
									owner = scope:AI_root
								}
							}
						}
					}
				}
				NOT = {
					any_neighbor_province = {
						is_in_list = AI_peace_wishlist_stage_1
					}
				}
			}
			remove_from_list = AI_peace_wishlist_stage_1
		}
	}
	# Remove landlocked provinces "sticking out" too far into enemy territory, to avoid lumpy borders
	every_in_list = {
		list = AI_peace_wishlist_stage_1
		limit = {
			is_coastal = no
		}
		set_local_variable = {
			name = num_surrounding_hostile_provs
			value = {
				every_neighbor_province = {
					limit = {
						trigger_if = {
							limit = {
								has_owner = yes
							}
							owner = {
								war_with = scope:AI_root
							}
							NOT = {
								any_neighbor_province = {
									trigger_if = {
										limit = {
											has_owner = yes
										}
										NOT = {
											owner = {
												war_with = scope:AI_root
											}
										}
									}
								}
							}
						}
					}
					if = {
						limit = {
							NOT = { is_in_list = AI_peace_wishlist_stage_1 }
						}
						add = 1
					}
				}
			}
		}
		set_local_variable = {
			name = num_surrounding_wishlisted_provs
			value = {
				every_neighbor_province = {
					limit = {
						trigger_if = {
							limit = {
								has_owner = yes
							}
							owner = {
								war_with = scope:AI_root
							}
							NOT = {
								any_neighbor_province = {
									trigger_if = {
										limit = {
											has_owner = yes
										}
										NOT = {
											owner = {
												war_with = scope:AI_root
											}
										}
									}
								}
							}
						}
					}
					if = {
						limit = {
							is_in_list = AI_peace_wishlist_stage_1
						}
						add = 1
					}
				}
			}
		}
		if = {
			limit = {
				has_local_variable = num_surrounding_hostile_provs
			}
			change_local_variable = {
				name = num_surrounding_hostile_provs
				divide = {
					value = local_var:num_surrounding_wishlisted_provs
					min = 1
				}
			}
			if = {
				limit = {
					local_var:num_surrounding_hostile_provs > 2.6
				}
				remove_from_list = AI_peace_wishlist_stage_1
			}
		}

	}

	## Now that we have this, start breaking them down into states
	# Any non "treaty-port" provinces should be taken as an entire state.
	# Entire states should be taken where >80% of the provinces were demanded
	every_war_$target$ = {
		every_country_state = {
			if = {
				limit = {
					AI_state_ratio_provinces_in_peace_wishlist >= 0.7
				}
				every_state_province = {
					add_to_list = AI_peace_wishlist_stage_1
				}
			}
			else = {
				every_state_province = {
				#	remove_from_list = AI_peace_wishlist_stage_1
				}
			}
		}
	}

	# TODO: Contiguousness cleanup
	# For states that are coastal:
	# Where the whole state is not in AI_peace_wishlist_stage_1, remove every non-coastal province
	# For states that are inland:
	# Where the whole state is not in AI_peace_wishlist_stage_1, remove every non-border province
	every_war_$target$ = {
		# Coastal
		every_country_state = {
			limit = {
				any_state_province = {
					is_coastal = yes
				}
			}
			if = {
				limit = {
					any_state_province = {
						NOT = { is_in_list = AI_peace_wishlist_stage_1 }
					}
				}
				every_state_province = {
					limit = {
						is_coastal = no
					}
					remove_from_list = AI_peace_wishlist_stage_1
				}
			}
		}
		# Inland
		every_country_state = {
			limit = {
				NOT = {
					any_state_province = {
						is_coastal = yes
					}
				}
			}
			if = {
				limit = {
					any_state_province = {
						NOT = { is_in_list = AI_peace_wishlist_stage_1 }
					}
				}
				every_state_province = {
					limit = {
						NOT = {
							any_neighbor_province = {
								trigger_if = {
									limit = {
										has_owner = yes
									}
									owner = scope:AI_root
								}
							}
						}
					}
					remove_from_list = AI_peace_wishlist_stage_1
				}
			}
		}
	}
	

	# TODO: Make the release / annex decision below into a separate scripted effect which is called here

	LAND_transfer_provinces = {
		target_provinces = AI_peace_wishlist_stage_1
		grantee = scope:AI_root
	}
	every_in_list = {
		list = AI_peace_wishlist_stage_1
		# Now we're going to add each region to a list, and release countries by region
		region = {
			if = {
				limit = {
					NOT = { is_in_list = releasable_region_list }
				}
				add_to_list = releasable_region_list
			}
		}

	}

	every_in_list = {
		list = releasable_region_list

		every_in_list = {
			list = released_from_war
			remove_from_list = released_from_war
		}
		every_region_province = {
			limit = {
				# We're going to exclude the AI_root's claims
				NOT = { is_core_of = scope:AI_root }
				is_in_list = AI_peace_wishlist_stage_1
			}
			add_to_list = released_from_war
		}

		if = {
			limit = {
				# Prevent colonies from releasing new client states
				scope:AI_root = {
					trigger_if = {
						limit = {
							is_subject = yes
						}
						NOR = {
							is_subject_type = client_colony
							is_subject_type = autonomous_colony
						}
					}
					trigger_else = {
						always = yes
					}
				}
			}
			LAND_release_from_list = {
				releaser = scope:AI_root
				list = released_from_war
				capital_location = by_population
				primary_culture = as_capital # TODO: Should be dynamic
				country_religion = as_capital # TODO: Should be dynamic
				as_subject_type = dynamic
				government_type = dynamic
				give_overlord_hos = yes # TODO: Should be dynamic
				country_flag = dynamic
				country_name = dynamic
				country_color = dynamic
			}
		}
		
	}

	every_in_list = {
		list = releasable_region_list
		remove_from_list = releasable_region_list
	}
	
	remove_global_variable = warscore_cost_available
}



# TODO:
## Creating an actual wishlist:
# Iterate through all coastal or neighbouring states in the enemy, ordered by total desirability
# Desirability = province value to AI_root, minus infamy cost of taking
# Add all the provinces in those list to a new list
# Order that list again by desirability, and add a big weight to desirability for bordering any owned province of the AI_root, or being coastal
# This way, the AI should try to make wishlists of contiguous, or sea-bordering, sensible provinces to take in a peace deal
## Taking provinces:
# Now iterate through the wishlist of provinces and add each one to a new list, actual takeable_provinces, and add their warscore cost to a local_var
# Once the accumulated warscore cost is above the affordable warscore end and transfer land
# If there's still un-expended warscore and we've done all in the list, go back to ## Creating an actual wishlist
# ...and do it again, treating provinces in the takeable_provinces list as owned by AI_root for the purposes of this iteration

# In the case of peace proposals to human players, the takeable_provinces list is presented as a list of demands for the player to accept or reject

# TODO: Consider how this needs to work handing land to subjects or allies, not just warleader

# In the case where the AI_root wants to vassalise the war target, expend warscore on that first, then consider taking land for themselves using the above wishlist method, but only for provinces over a certain desirability threshhold.

###########################

AI_debug_peace_deal_all_wars = {
	every_in_list = {
		list = wars_checked
		remove_from_list = wars_checked
	}

	every_country = {
		limit = {
			war = yes
		}
		every_current_war = {
			limit = {
				NOT = {
					THIS = { is_in_list = wars_checked }
				}
			}
			# TODO: Make a version which specifies the AI_root scope
			# And then use this to go through the ordered members of a war
			# in inverse order of diplomacy power, so the smallest contributors get to act first
			# The warscore available to each one is scaled by diplomacy power
			AI_make_peace_province_wishlist_p0 = {
				target = defender
			}

			add_to_list = wars_checked
		}
	}
}

AI_debug_restitute_land = {
	every_in_list = {
		list = restituted_land
		remove_from_list = restituted_land
	}
	every_province = {
		limit = {
			has_variable = debug_original_owner
		}
		if = {
			limit = {
				exists = var:debug_original_owner
			}
			add_to_list = restituted_land
		}
	}

	LAND_transfer_provinces = {
		target_provinces = restituted_land
		grantee = var:debug_original_owner
	}
	every_in_list = {
		list = restituted_land
		remove_variable = debug_original_owner
	}
}

AI_make_peace_deal = {
	# Scope: War
	# Function: Settle a peace deal for AI countries
	# If the other party in the war is a player, send them an offer to consider
}

# ECONOMY

## CURRENCY
### Take out debt

## TAXES
### Change tax rates

# CONSTRUCTION

### Build buildings, as the government