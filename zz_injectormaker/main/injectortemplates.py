# -*- coding: utf-8 -*-
"""
Created on Thu May  6 12:52:38 2021

@author: Tobias Gr√∏sfjeld
"""

# To consider if this grows to a larger size: Optimize by using sets instead of lists wherever order doesn't matter.
from datetime import date
# This file is for just listing all the strings that should be encoded by injectormaker.py
# It can do so dynamically or based on hardcoded lists.

exclusion_keys = {
    "#",
    "@",
    "modifier",
    "character_modifier",
    "if",
    "else",
	"elseif",
	"else_if",
    "\n",
    "can_have",
    "can_keep",
    "can_pass",
    "on_pass",
    "on_revoke",
    "should_start_with",
    "graphical_cultures",
    "pass_cost",
    "desc",
    "compatibility",
    "name",
    "opposites",
    "triggered_opinion",
    "icon",
	"random_list",
	"limit",
	"random"
    }
# Bools for reading specific lines
def should_read(x,level=0):
    y = x.split("#")[0]
    z = y.split("=")[0]
    return ("= {" in y and z.count("\t")+z.count("    ") == level and not z.strip() in exclusion_keys) #"#" and not y[0]=="@")
def should_read_base(y):
    return ("=" in y and not "\t" in y and not y[0]=="#" and not y[0]=="@")
def should_read_policy(y):
    return ("= {" in y and y.count("\t") == 1 and not y[0]=="#")

# This goes at the top of the generated file
initial_template = """
########################################################
#### This file is autogenerated by injectormaker.py ####
################# Last run: """+date.today().strftime("%Y-%m-%d")+""" #################
########################################################
## This file contains "MAIN_KEY_hypercomplex" iterators for unscoped types "MAIN_KEY" over "ITERATION_KEY"
## This is intended for intermediate parsing functions such as those defined as metainjectors, and takes parameters:
# CONTROLLER: switch, random_list, if, etc; some function which allows effects inside it.
# PRESTATEMENT_KEY, PRESTATEMENT_ARG: For example trigger = has_trait or limit = {has_trait = honest}
# PREFIX, SUFFIX: Wrapper for passing case data to random lists or switches
# APPLY: Scripted effect, taking $ITERATION_KEY$. For example, if ITERATION_KEY is "LIFESTYLE" then the APPLY should be of the form some_lifestyle_effect = {LIFESTYLE = my_key}
# EXTRA_KEY, EXTRA_ARG: Potential extra arguments to pass to APPLY. Can be commented out or used to pass extra arguments.

#####################
### Metainjectors ###
#####################
# These handle the basic formats expected to be accessible by any type of injector
# Similar functions may be defined on a case-by-case basis.
# Allows evaluation of simple assign functions in otherwise complex assign injectors
simply_assign = { # APPLY and ARGUMENT
	$APPLY$ = $ARGUMENT$
}
# Switch parses a flag into a string key from TYPE
parse_type_flag_complex = { # parse_type_flag_complex = {TYPE, KEY, APPLY, FLAG}
	$TYPE$_hypercomplex = {
		CONTROLLER = switch
		PRESTATEMENT_KEY = trigger
		PRESTATEMENT_ARG = $FLAG$
		PREFIX = "flag:"
		SUFFIX = ""
		APPLY = $APPLY$
		KEY = $KEY$
		EXTRA_KEY = "#"
		EXTRA_ARG = "#"
	}
}
# Switch with any simple_assign trigger over the keys
switch_type_complex = { # TYPE, KEY, TRIGGER = simple_assign, APPLY = scripted_effect {KEY}
	$TYPE$_hypercomplex = {
		CONTROLLER = switch
		PRESTATEMENT_KEY = trigger
		PRESTATEMENT_ARG = $TRIGGER$
		PREFIX = ""
		SUFFIX = ""
		APPLY = $APPLY$
		KEY = $KEY$
		EXTRA_KEY = "#"
		EXTRA_ARG = "#"
	}
}
# Executes APPLY = {KEY = key} for every key in TYPE
every_type_complex = { # every_type_complex = {TYPE, KEY, APPLY}
	$TYPE$_hypercomplex = {
		CONTROLLER = if
		PRESTATEMENT_KEY = "limit"
		PRESTATEMENT_ARG = "{always = yes}"
		PREFIX = "if = {limit = {always = yes}#"
		SUFFIX = "#"
		APPLY = $APPLY$
		KEY = $KEY$
		EXTRA_KEY = "#"
		EXTRA_ARG = "#"
	}
}
# Executes APPLY = {KEY = key} for a random key in TYPE
random_type_complex = { # random_type_complex = {TYPE, KEY, APPLY}
	$TYPE$_hypercomplex = {
		CONTROLLER = random_list
		PRESTATEMENT_KEY = "#"
		PRESTATEMENT_ARG = "#"
		PREFIX = "1 = {#"
		SUFFIX = "}#"
		APPLY = $APPLY$
		KEY = $KEY$
		EXTRA_KEY = "#"
		EXTRA_ARG = "#"
	}
}
## Metainjectors for APPLY = simple_assign. Same endpoint usage as complex assign.
# Switch parses a flag into a string key from TYPE
parse_type_flag_simple = { # TYPE, FLAG = flag, APPLY = simple_assign
	$TYPE$_hypercomplex = {
		CONTROLLER = switch
		PRESTATEMENT_KEY = trigger
		PRESTATEMENT_ARG = $FLAG$
		PREFIX = "flag:"
		SUFFIX = ""
		APPLY = simply_assign
		KEY = ARGUMENT
		EXTRA_KEY = APPLY
		EXTRA_ARG = $APPLY$
	}
}
# Switch with any simple_assign trigger over the keys in TYPE
switch_type_simple = { # TYPE, TRIGGER = simple_assign, APPLY = simple_assign
	$TYPE$_hypercomplex = {
		CONTROLLER = switch
		PRESTATEMENT_KEY = trigger
		PRESTATEMENT_ARG = $TRIGGER$
		PREFIX = ""
		SUFFIX = ""
		APPLY = simply_assign
		KEY = ARGUMENT
		EXTRA_KEY = APPLY
		EXTRA_ARG = $APPLY$
	}
}
# Executes APPLY = KEY for every KEY in TYPE
every_type_simple = { # {TYPE, APPLY}
	$TYPE$_hypercomplex = {
		CONTROLLER = if
		PRESTATEMENT_KEY = "limit"
		PRESTATEMENT_ARG = "{always = yes}"
		PREFIX = "if = {limit = {always = yes}#"
		SUFFIX = "#"
		APPLY = simply_assign
		KEY = ARGUMENT
		EXTRA_KEY = APPLY
		EXTRA_ARG = $APPLY$
	}
}
# Executes APPLY = KEY for a random KEY in TYPE
random_type_simple = { # TYPE, APPLY = simple_assign
	$TYPE$_hypercomplex = {
		CONTROLLER = random_list
		PRESTATEMENT_KEY = "#"
		PRESTATEMENT_ARG = "#"
		PREFIX = "1 = {#" 
		SUFFIX = "}#"
		APPLY = simply_assign
		KEY = ARGUMENT
		EXTRA_KEY = APPLY
		EXTRA_ARG = $APPLY$
	}
}
"""

# Wraps the iterant_template
wrapping_template = """
##############################################################
#### Main key: MAIN_KEY: Iteration key: SECONDARY_KEY
##############################################################
# Execute APPLY for the SECONDARY_KEY key passed as a flag:FLAG.
# parse_MAIN_KEY_flag_complex = {SECONDARY_KEY = flag APPLY = scripted_effect}
# parse_MAIN_KEY_flag_simple  = {SECONDARY_KEY = flag APPLY = simple_effect}
parse_MAIN_KEY_flag_complex   = {parse_type_flag_complex  = {TYPE = MAIN_KEY APPLY = $APPLY$ FLAG = $SECONDARY_KEY$  KEY = SECONDARY_KEY}}
parse_MAIN_KEY_flag_simple    = {parse_type_flag_simple   = {TYPE = MAIN_KEY APPLY = $APPLY$ FLAG = $SECONDARY_KEY$}}
# Execute APPLY in a switch statement for the keys
# switch_MAIN_KEY_complex     = {APPLY = scripted_effect TRIGGER = simple_trigger}
# switch_MAIN_KEY_simple      = {APPLY = simple_effect   TRIGGER = simple_trigger}
switch_MAIN_KEY_complex       = {switch_type_complex      = {TYPE = MAIN_KEY APPLY = $APPLY$ TRIGGER = $TRIGGER$  KEY = SECONDARY_KEY}}
switch_MAIN_KEY_simple        = {switch_type_simple       = {TYPE = MAIN_KEY APPLY = $APPLY$ TRIGGER = $TRIGGER$}}
# Execute APPLY for every MAIN_KEY key
# every_MAIN_KEY_complex      = {APPLY = scripted_effect}
# every_MAIN_KEY_simple       = {APPLY = simple_effect}
every_MAIN_KEY_complex        = {every_type_complex       = {TYPE = MAIN_KEY APPLY = $APPLY$ KEY = SECONDARY_KEY}}
every_MAIN_KEY_simple         = {every_type_simple        = {TYPE = MAIN_KEY APPLY = $APPLY$}}
# Execute APPLY for a random MAIN_KEY key
# random_MAIN_KEY_complex     = {APPLY = scripted_effect}
# random_MAIN_KEY_simple      = {APPLY = simple_effect}
random_MAIN_KEY_complex       = {random_type_complex      = {TYPE = MAIN_KEY APPLY = $APPLY$ KEY = SECONDARY_KEY}}
random_MAIN_KEY_simple        = {random_type_simple       = {TYPE = MAIN_KEY APPLY = $APPLY$}}
### Hypercomplex iterator for unscoped type "MAIN_KEY" over SECONDARY_KEY:
MAIN_KEY_hypercomplex = {
	$CONTROLLER$ = {
		$PRESTATEMENT_KEY$ = $PRESTATEMENT_ARG$ITERANT
    }
}
"""
# Goes inside the wrapping_template, once for each iterant_key
iterant_template = """
		$PREFIX$ITERANT_KEY$SUFFIX$ = {
			$APPLY$ = {
				$KEY$ = ITERANT_KEY
				$EXTRA_KEY$ = $EXTRA_ARG$
			}
		}"""