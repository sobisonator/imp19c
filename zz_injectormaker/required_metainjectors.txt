# Unless you use the file produced by "Export All", you must put this file in your scripted_effects folder to run manually exported injectors. 
# The same code can be found in the file produced by 'Export All'.

########################################################
#### This file is autogenerated by injectormaker.py ####
################# Last run: 2022-10-23 #################
########################################################
## This file contains "MAIN_KEY_hypercomplex" iterators for unscoped types "MAIN_KEY" over "ITERATION_KEY"
## This is intended for intermediate parsing functions such as those defined as metainjectors, and takes parameters:
# CONTROLLER: switch, random_list, if, etc; some function which allows effects inside it.
# PRESTATEMENT_KEY, PRESTATEMENT_ARG: For example trigger = has_trait or limit = {has_trait = honest}
# PREFIX, SUFFIX: Wrapper for passing case data to random lists or switches
# APPLY: Scripted effect, taking $ITERATION_KEY$. For example, if ITERATION_KEY is "LIFESTYLE" then the APPLY should be of the form some_lifestyle_effect = {LIFESTYLE = my_key}
# EXTRA_KEY, EXTRA_ARG: Potential extra arguments to pass to APPLY. Can be commented out or used to pass extra arguments.

#####################
### Metainjectors ###
#####################
# These handle the basic formats expected to be accessible by any type of injector
# Similar functions may be defined on a case-by-case basis.
# Allows evaluation of simple assign functions in otherwise complex assign injectors
simply_assign = { # APPLY and ARGUMENT
	$APPLY$ = $ARGUMENT$
}
# Switch parses a flag into a string key from TYPE
parse_type_flag_complex = { # parse_type_flag_complex = {TYPE, KEY, APPLY, FLAG}
	$TYPE$_hypercomplex = {
		CONTROLLER = switch
		PRESTATEMENT_KEY = trigger
		PRESTATEMENT_ARG = $FLAG$
		PREFIX = "flag:"
		SUFFIX = ""
		APPLY = $APPLY$
		KEY = $KEY$
		EXTRA_KEY = "#"
		EXTRA_ARG = "#"
	}
}
# Switch with any simple_assign trigger over the keys
switch_type_complex = { # TYPE, KEY, TRIGGER = simple_assign, APPLY = scripted_effect {KEY}
	$TYPE$_hypercomplex = {
		CONTROLLER = switch
		PRESTATEMENT_KEY = trigger
		PRESTATEMENT_ARG = $TRIGGER$
		PREFIX = ""
		SUFFIX = ""
		APPLY = $APPLY$
		KEY = $KEY$
		EXTRA_KEY = "#"
		EXTRA_ARG = "#"
	}
}
# Executes APPLY = {KEY = key} for every key in TYPE
every_type_complex = { # every_type_complex = {TYPE, KEY, APPLY}
	$TYPE$_hypercomplex = {
		CONTROLLER = if
		PRESTATEMENT_KEY = "limit"
		PRESTATEMENT_ARG = "{always = yes}"
		PREFIX = "if = {limit = {always = yes}#"
		SUFFIX = "#"
		APPLY = $APPLY$
		KEY = $KEY$
		EXTRA_KEY = "#"
		EXTRA_ARG = "#"
	}
}
# Executes APPLY = {KEY = key} for a random key in TYPE
random_type_complex = { # random_type_complex = {TYPE, KEY, APPLY}
	$TYPE$_hypercomplex = {
		CONTROLLER = random_list
		PRESTATEMENT_KEY = "#"
		PRESTATEMENT_ARG = "#"
		PREFIX = "1 = {#"
		SUFFIX = "}#"
		APPLY = $APPLY$
		KEY = $KEY$
		EXTRA_KEY = "#"
		EXTRA_ARG = "#"
	}
}
## Metainjectors for APPLY = simple_assign. Same endpoint usage as complex assign.
# Switch parses a flag into a string key from TYPE
parse_type_flag_simple = { # TYPE, FLAG = flag, APPLY = simple_assign
	$TYPE$_hypercomplex = {
		CONTROLLER = switch
		PRESTATEMENT_KEY = trigger
		PRESTATEMENT_ARG = $FLAG$
		PREFIX = "flag:"
		SUFFIX = ""
		APPLY = simply_assign
		KEY = ARGUMENT
		EXTRA_KEY = APPLY
		EXTRA_ARG = $APPLY$
	}
}
# Switch with any simple_assign trigger over the keys in TYPE
switch_type_simple = { # TYPE, TRIGGER = simple_assign, APPLY = simple_assign
	$TYPE$_hypercomplex = {
		CONTROLLER = switch
		PRESTATEMENT_KEY = trigger
		PRESTATEMENT_ARG = $TRIGGER$
		PREFIX = ""
		SUFFIX = ""
		APPLY = simply_assign
		KEY = ARGUMENT
		EXTRA_KEY = APPLY
		EXTRA_ARG = $APPLY$
	}
}
# Executes APPLY = KEY for every KEY in TYPE
every_type_simple = { # {TYPE, APPLY}
	$TYPE$_hypercomplex = {
		CONTROLLER = if
		PRESTATEMENT_KEY = "limit"
		PRESTATEMENT_ARG = "{always = yes}"
		PREFIX = "if = {limit = {always = yes}#"
		SUFFIX = "#"
		APPLY = simply_assign
		KEY = ARGUMENT
		EXTRA_KEY = APPLY
		EXTRA_ARG = $APPLY$
	}
}
# Executes APPLY = KEY for a random KEY in TYPE
random_type_simple = { # TYPE, APPLY = simple_assign
	$TYPE$_hypercomplex = {
		CONTROLLER = random_list
		PRESTATEMENT_KEY = "#"
		PRESTATEMENT_ARG = "#"
		PREFIX = "1 = {#" 
		SUFFIX = "}#"
		APPLY = simply_assign
		KEY = ARGUMENT
		EXTRA_KEY = APPLY
		EXTRA_ARG = $APPLY$
	}
}
