
####################################
############# TUTORIAL #############
####################################
####################################
### PART 0: What's the big idea? ###
####################################
# In CK3 there are a bunch of functions that are a hassle to keep updated in our projects. In particular:
# Functions which check a bunch of cases from some database, like has_government = tribal_government and then do something based on it.
# Functions which read a saved variable that doesn't have a proper scope type, like flag:some_trait or flag:some_law.
# Functions which fire an effect over some list, either randomly or over every instance in the list.
# Every time we add another government type, law, or trait, we'd need to manually update all functions of these types across the mod.
# This tool aims to help with keeping such functions updated by keeping them all in a single iterator.
# We just add our cases to the master list and it automatically updates all the dependant functions.
# Though perfect understanding of the script is not necessary to use this tool, 
# it helps with being able to hook into the system to create new functionality.
# Examples of such custom expansion are given at the end of this tutorial.

# Default easy-to-use generated functions and example invocations for a given MAIN_KEY and SECONDARY_KEY:
# Execute APPLY for the SECONDARY_KEY key passed as some flag-valued stored scope value or variable, for example scope:some_flag or var:my_flag.
parse_MAIN_KEY_flag_complex = {SECONDARY_KEY = scope:some_flag APPLY = scripted_effect}
parse_MAIN_KEY_flag_simple  = {SECONDARY_KEY = scope:some_flag APPLY = simple_effect}
# Execute APPLY in a switch statement for the keys
switch_MAIN_KEY_complex     = {APPLY = scripted_effect TRIGGER = simple_trigger}
switch_MAIN_KEY_simple      = {APPLY = simple_effect   TRIGGER = simple_trigger}
# Execute APPLY for every MAIN_KEY key
every_MAIN_KEY_complex      = {APPLY = scripted_effect}
every_MAIN_KEY_simple       = {APPLY = simple_effect}
# Execute APPLY for a random MAIN_KEY key
random_MAIN_KEY_complex     = {APPLY = scripted_effect}
random_MAIN_KEY_simple      = {APPLY = simple_effect}

### INDEX OF THIS TUTORIAL
## Chapter 1: Understanding the script
# Part 1: Examples
# Part 2: Simplified Complexity
# Part 3: Hypercomplexes
# Part 4: Metainjectors
## Chapter 2: The injectormaker tool
# Part 5: Using the tool
# Part 6: Example script expansions

########################
####### CHAPTER 1 ######
### PART 1: Examples ###
########################

# Consider the following 8 example functions, constructed by MAIN_KEY = policy, SECONDARY_KEY = LAW
# with the iterant keys "police_authority_0", "police_authority_1", etc.

# switch_policy_complex = {APPLY = my_scripted_effect TRIGGER = has_realm_law} be like
switch = {
    trigger = has_realm_law
    police_authority_0 = { my_scripted_effect = {LAW = police_authority_0}}
    police_authority_1 = { my_scripted_effect = {LAW = police_authority_1}}
}
# switch_policy_simple = {APPLY = revoke_realm_law TRIGGER = has_realm_law} be like
switch = {
	trigger = has_realm_law
	police_authority_0 = { revoke_realm_law = police_authority_0}
	police_authority_1 = { revoke_realm_law = police_authority_1}
}
# parse_policy_flag_complex = {APPLY = my_scripted_effect LAW = scope:law_flag} be like
switch = {
    trigger = scope:law_flag
    flag:police_authority_0 = { my_scripted_effect = {LAW = police_authority_0}}
    flag:police_authority_1 = { my_scripted_effect = {LAW = police_authority_1}}
}
# parse_policy_flag_simple = {APPLY = revoke_realm_law LAW = scope:law_flag} be like
switch = {
    trigger = scope:law_flag
    flag:police_authority_0 = { revoke_realm_law = police_authority_0}
    flag:police_authority_1 = { revoke_realm_law = police_authority_1}
}
# random_policy_complex = {APPLY = my_scripted_effect} be like 
random_list = {
    1 = { my_scripted_effect = {LAW = police_authority_0}}
    1 = { my_scripted_effect = {LAW = police_authority_1}}
}
# random_policy_simple = {APPLY = revoke_realm_law} be like 
random_list = {
	1 = { revoke_realm_law = police_authority_0}
	1 = { revoke_realm_law = police_authority_1}
}
# every_policy_complex = {APPLY = my_scripted_effect} be like
my_scripted_effect = {LAW = police_authority_0}
my_scripted_effect = {LAW = police_authority_1}
my_scripted_effect = {LAW = police_authority_2}

# every_policy_simple = {APPLY = revoke_realm_law} be like
revoke_realm_law = police_authority_0
revoke_realm_law = police_authority_1
revoke_realm_law = police_authority_2

# List-based functions like the above are autogenerated by this tool for each class of "stuff" which we would like to iterate over.

#####################################
### PART 2: Simplified complexity ###
#####################################
# In CK3 there are fundamentally two types of assignment: Complex, i.e. statements of the form A = {B = C} and Simple, i.e. A = B.
# All scripted effects must be either complex assign or so simple that they only take "yes" as a simple input.
# However, by making a scripted effect called simply_assign which takes {APPLY = some_effect ARGUMENT = some_argument}, defined as
simply_assign = {$APPLY$ = $ARGUMENT$}
# We can turn simple assigns into complex assigns.
# We therefore need a generic system to handle only the four types of complex assign function, such that we can pass two parameters to it.

##############################
### PART 3: Hypercomplexes ###
##############################
# What do the functions of interest have in common? 
# They may or may not have a controller, like "switch" or "random_list".
# They may or may not have a prestatement pair, like trigger = has_realm_law or trigger = scope:law_flag
# They may or may not have a case-condition statement, like flag:police_authority_0 = { or 1 = {. 
# In general, the case-condition statement must be able to depend on the case.
# If a case is fired, it executes some preset function with possibly some keyed parameter pairs (LAW = case_key)
# Ideally we would also be able to handle additional keyed parameter pairs, so we aren't restricted to functions with a single parameter.

# We conclude that the most general form of statement looks something like this:
policy_hypercomplex = {
	$CONTROLLER$ = {
		$PRESTATEMENT_KEY$ = $PRESTATEMENT_ARG$
		$PREFIX$police_authority_0$SUFFIX$ = {
			$APPLY$ = {
				$KEY$ = police_authority_0
				$EXTRA_KEY$ = $EXTRA_ARG$
			}
		}
		$PREFIX$police_authority_1$SUFFIX$ = {
			$APPLY$ = {
				$KEY$ = police_authority_1
				$EXTRA_KEY$ = $EXTRA_ARG$
			}
		}
    }
}
# This is called a hypercomplex because it is a function which constructs other complex functions when compiled.
# We may verify that by carefully inserting the strings we want in place of the places encapsulated with $$,
# (Possibly including stuff like "= {#" or "}#", which will dynamically comment out parts of the script) 
# we can reproduce the above functions.
# For example, consider how this function would be evaluated:
parse_policy_flag_complex = { # Usage: parse_policy_flag_complex = {APPLY = my_effect LAW = scope:law_flag}
	policy_hypercomplex = {
		CONTROLLER = switch
		PRESTATEMENT_KEY = trigger
		PRESTATEMENT_ARG = $LAW$
		PREFIX = "flag:"
		SUFFIX = ""
		APPLY = $APPLY$
		KEY = LAW
		EXTRA_KEY = "#"
		EXTRA_ARG = "#"
	}
}
# It will be evaluated as
	switch = {
		trigger = $LAW$
		flag:police_authority_0 = {
			$APPLY$ = {
				LAW = police_authority_0
				# = #
			}
		}
		flag:police_authority_1 = {
			$APPLY$ = {
				LAW = police_authority_1
				# = #
			}
		}
    }
# And can therefore be used at runtime as
parse_policy_flag_complex = {APPLY = my_effect LAW = scope:law_flag} to execute my_effect for the <string> stored in scope:law_flag = flag:<string>

#############################
### PART 4: Metainjectors ###
#############################
# Even if we can write scripted effects that use the hypercomplex directly as in the preceding example, that's still a lot of code duplication.
# I've therefore included some template "metainjectors" that can be used by a plethora of effects.
# These are automatically included by clicking "Export All" in the tool, but will be printed in a separate file if separate files are preferred.
# They take care of the type-agnostic code repetition in order to minimize the likelihood of errors.
# For example: Regardless of type, there's really only one structure needed to compute a flag-parsing switch statement.
parse_type_flag_complex = { # parse_type_flag_complex = {TYPE, KEY, APPLY, FLAG}
	$TYPE$_hypercomplex = {
		CONTROLLER = switch
		PRESTATEMENT_KEY = trigger
		PRESTATEMENT_ARG = $FLAG$
		PREFIX = "flag:"
		SUFFIX = ""
		APPLY = $APPLY$
		KEY = $KEY$
		EXTRA_KEY = "#"
		EXTRA_ARG = "#"
	}
}
# Which means the export of the policy type itself can get away with only defining
parse_policy_flag_complex   = {parse_type_flag_complex  = {TYPE = policy APPLY = $APPLY$ FLAG = $LAW$  KEY = LAW}}
# Which finally is invoked by the end-user (In some event) as
parse_policy_flag_complex = {APPLY = my_law_effect LAW = scope:some_law_flag}

##############################
########## CHAPTER 2 #########
### PART 5: Using the tool ###
##############################

## Bottom bar buttons:
# Add File: Loads a specific file to be parsed by the script.
# Export All: Exports all loaded files into a single document, including metainjectors. 
#             Drop the resulting file into the scripted_effects folder, and it's ready to inject!
# Save Export List: Writes a file with information on paths, keys and inspection level.
# Load Export List: Loads a file previously saved with "Save Export List" and quickly refreshes the iteration keys from the relevant files.
# Dump Tutorial.info: Congratulations, you've already figured out what this button does!

# Once the desired files have been loaded and the inspection level has been set, we must choose a Main Key and a Secondary Key.
# The main key will be how we refer to the script in the future (So "policy" will let us use commands like random_policy_simple)
# The secondary key determines what kind of effects we can pass as an APPLY to the commands that end in _complex.
# For example, if I choose the secondary key to be "LAW" then I can pass my_law_effect = {revoke_realm_law = $LAW$} via 
random_policy_complex = {APPLY = my_law_effect}

# NOTE: Clicking "Export All" merges any entries that share a Main Key into a single function. 
# This is because it makes no sense to have two separate functions both called policy_hypercomplex.

## Widget buttons:
# Inspect Keys: Shows the keys loaded from the relevant file.
#               If the keys shown are not the desired keys, click "Inspect level" to toggle which layer of keys should be detected. 
#               For example, trait and government keys are top-level blocks and are therefore picked up at inspection level 0.
#               Conversely, culture and law keys are inside law group blocks and therefore require inspection level 1.
#               NOTE: If the desired list of keys would not be detected by these simple inspection methods,
#               then we may instead make a separate text file which contains only those keys, and read that.
# Inspect Level: As explained above, clicking this button iterates through the layer at which a key is detected (By how many tabs precede the key)
# Export: Creates a file called <main_key>_injector.txt and required_metainjectors.txt. Put both of these into the scripted_effects folder
#           NOTE: required_injectors.txt is not necessary if there already is a file there generated by Export All.
            It is recommended to use Export All instead of Export, unless you know what you're doing and you want to intentionally split your files.
# Remove: Removes this item from the export list. Will not remove it from a Save unless the Save is overwritten.

#########################################
### PART 6: Example script expansions ###
#########################################
# Sometimes we need to write iterator functions which go beyond what the pregenerated template functions can do.
# For example, we may want to write one where the probability of a random effect depends on a script value.
# Or, we may want to conditionally exclude certain outcomes based on a trigger.
#
# By hooking our functions into the hypercomplex, we'll usually never have to update our script for maintenance in the future.
#
# As an instructive exercise, try substituting the following parameters into the previously stated policy_hypercomplex.
# (Here has_advanced_policies and my_script_value_<key> are custom scripted_triggers and script_values, respectively.)
every_owned_policy_complex = { # APPLY = complex_effect
	policy_hypercomplex = {
		CONTROLLER = if
		PRESTATEMENT_KEY = "limit"
		PRESTATEMENT_ARG = "{has_advanced_policies = yes}"
		PREFIX = "if = {limit = {has_realm_law ="
		SUFFIX = "}#"
		APPLY = $APPLY$
		KEY = LAW
		EXTRA_KEY = "#"
		EXTRA_ARG = "#"
	}
}
random_owned_policy_simple = { # APPLY = simple_effect
	policy_hypercomplex = {
		CONTROLLER = random_list
		PRESTATEMENT_KEY = "#"
		PRESTATEMENT_ARG = "#"
		PREFIX = "1 = {trigger = {has_realm_law =" 
		SUFFIX = "}#"
		APPLY = simply_assign_law
		KEY = LAW
		EXTRA_KEY = APPLY
		EXTRA_ARG = $APPLY$
	}
}
weighted_random_owned_policy_complex = { # APPLY = complex_effect SECOND_LAW = some_other_law
	policy_hypercomplex = {
		CONTROLLER = random_list
		PRESTATEMENT_KEY = "#"
		PRESTATEMENT_ARG = "#"
		PREFIX = "0 = {modifier = {add = my_script_value_"
		SUFFIX = "}#"
		APPLY = $APPLY$
		KEY = LAW
		EXTRA_KEY = SECOND_LAW
		EXTRA_ARG = $SECOND_LAW$
	}
}
